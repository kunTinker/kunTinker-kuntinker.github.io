<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tingke.github.io/</id>
    <title>好学习</title>
    <updated>2020-07-04T14:58:59.542Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tingke.github.io/"/>
    <link rel="self" href="https://tingke.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://tingke.github.io/images/avatar.png</logo>
    <icon>https://tingke.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 好学习</rights>
    <entry>
        <title type="html"><![CDATA[前端基础之CSS属性]]></title>
        <id>https://tingke.github.io/post/iZ7sJPRIL/</id>
        <link href="https://tingke.github.io/post/iZ7sJPRIL/">
        </link>
        <updated>2020-07-04T09:17:20.000Z</updated>
        <content type="html"><![CDATA[<p>前面介绍了CSS的选择器，既然选择了正确的标签，我们该如何改变标签的样式呢？</p>
<h2 id="0x00-文本元素">0x00 文本元素</h2>
<p>1、属性</p>
<pre><code class="language-css">font-size: 50px;         /*文字大小*/
font-weight: 700;       /*值从100-900，文字粗细,700约等于Bold，不推荐使用font-weight:bold; */
font-family:微软雅黑;    /*文本的字体*/
font-style: normal | italic;  /*normal:默认值  italic:斜体*/
line-height: 50px;            /*行高*/
</code></pre>
<p>2、文本属性连写</p>
<pre><code class="language-css">/* 格式：font: font-style font-weight  font-size/line-height  font-family; */
font: italic 700 50px/40px  微软雅黑;
</code></pre>
<p>注意：font:后边写属性的值。一定按照书写顺序。<br>
PS：文本属性连写中文字大小和字体为必写项。</p>
<p>3、文字的表达方式</p>
<pre><code class="language-css">font-family: 微软雅黑; // 直接写中文名称
font-family: microsoft yahei; // 写字体的英文名称
font-family: \5FAE\8F6F\96C5\9ED1; // unicode 编码（解析更快）
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端基础之CSS选择器]]></title>
        <id>https://tingke.github.io/post/3TADld0ke/</id>
        <link href="https://tingke.github.io/post/3TADld0ke/">
        </link>
        <updated>2020-07-04T08:50:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="0x00-简单认识css">0x00 简单认识CSS</h2>
<h3 id="1-什么是-css">1、什么是 CSS？</h3>
<p><code>CSS</code> 全称为 <code>Cascading Style Sheets</code>，中文翻译为“层叠样式表”，简称 CSS 样式表，所以称之为层叠样式表（Cascading Stylesheet）简称 CSS。在网页制作时采用 CSS 技术，可以有效地对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制。只要对相应的代码做一些简单的修改，就可以改变同一页面的不同部分，或者页数不同的网页的外观和格式。</p>
<h3 id="2-css-的作用">2、CSS 的作用</h3>
<p>简单地来讲，CSS 能对你制作的网页进行布局、颜色、背景、宽度、高度、字体进行控制，让网页按您的美工设计布局的更加美观漂亮。 样式是用来控制页面外观、设置元素对象属性的工具，使用样式可使页面产生各种特殊的效果。</p>
<h3 id="3-样式表书写位置">3、样式表书写位置</h3>
<pre><code class="language-html">&lt;head&gt;
	&lt;meta charset=&quot;UTF-8&quot;&gt;
	&lt;title&gt;Document&lt;/title&gt;
	&lt;style type=&quot;text/css&quot;&gt;
	    /* 样式表内容 */
	&lt;/style&gt;
&lt;/head&gt;
</code></pre>
<h2 id="0x01-选择器">0x01 选择器</h2>
<h3 id="什么是选择器">什么是选择器？</h3>
<p>选择器是一个选择标签的过程。</p>
<p>以下选择器会选取这个示例中出现举例</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;UTF-8&quot;&gt;
	&lt;title&gt;Document&lt;/title&gt;
	&lt;style type=&quot;text/css&quot;&gt;
		div{
			font-size: 50px;
			color: red
		}
	&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;div&gt;等你下课&lt;/div&gt;
    &lt;div class=&quot;box&quot;&gt;我是一个box&lt;/div&gt;
    &lt;div id=&quot;box&quot;&gt;我也是一个box&lt;/div&gt;
    &lt;div&gt;&lt;div class=&quot;box&quot;&gt;大家都是box&lt;/div&gt;&lt;/div&gt;
    &lt;div&gt;我是谁？&lt;span&gt;我在哪？&lt;/span&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="基础选择器">基础选择器</h3>
<h4 id="标签选择器">标签选择器</h4>
<p>示例：</p>
<pre><code class="language-css">div {
    width: 100px;
}
</code></pre>
<p>特点：<br>
标签选择器定义之后，会将页面所有的元素都执行这个标签样式。</p>
<h4 id="类选择器重点">类选择器（重点）</h4>
<p>示例：</p>
<pre><code class="language-css">.box {
    width: 100px;
    height: 100px;
    background-color: red;
}
</code></pre>
<p>特点：<br>
一个标签可以调用多个类选择器。多个标签可以调用同一个类选择器。</p>
<p><strong>类选择器命名规则</strong></p>
<ol>
<li>不能用纯数字或者数字开头来定义类名；</li>
<li>不能使用特殊符号或者特殊符号开头（_ 除外）来定义类名；</li>
<li>不建议使用汉字来定义类名；</li>
<li>不推荐使用属性或者属性的值来定义类名。</li>
</ol>
<p><strong>类选择器常用的命名</strong></p>
<pre><code>header：头部
content/contrainer：内容
footer：底部
nav：导航栏
sidebar：侧边栏
wrapper：外围包装
left：左
right：右
center：中
loginbar：登录条
logo：标志
banner：广告
main：主体
hot：热点
copyright：版权
</code></pre>
<h3 id="id选择器">ID选择器</h3>
<p>示例：</p>
<pre><code class="language-css">#box {
    width: 100px;
    height: 100px;
    background-color: red;
}
</code></pre>
<p>特点：</p>
<ul>
<li>一个 ID 选择器在一个页面只能使用一次。如果使用2次或者2次以上，不符合 w3c 规范，JS 调用会出问题。</li>
<li>一个标签只能使用一个 ID 选择器。</li>
<li>一个标签可以同时使用类选择器和 ID 选择器。</li>
</ul>
<h3 id="通配符选择器">通配符选择器</h3>
<p>示例：</p>
<pre><code class="language-css">* {
    color: #000;
    margin: 0;
    padding: 0;
}
</code></pre>
<p>特点：<br>
给所有的标签都使用相同的样式。<br>
PS：★不推荐使用，增加浏览器和服务器负担。</p>
<h2 id="复合选择器">复合选择器</h2>
<p>两个或者两个以上的基础选择器通过不同的方式连接在一起。</p>
<h4 id="交集选择器">交集选择器</h4>
<p>示例：</p>
<pre><code class="language-css">div.box {
    width: 100px;
    height: 100px;
    background-color: red;
}
</code></pre>
<p>特点：<br>
即要满足使用了某个标签，还要满足使用了类选择器或者ID选择器。</p>
<h4 id="后代选择器重点">后代选择器（重点）</h4>
<p>示例：</p>
<pre><code class="language-css">div span {
    width: 100px;
    height: 100px;
    background-color: red;
}
</code></pre>
<p>特点：</p>
<ul>
<li>后代选择器首选要满足包含（嵌套）关系。</li>
<li>父集元素在前边，子集元素在后边。</li>
<li>无限制隔代。（下面都会生效）</li>
<li>只要能代表标签，标签、类选择器、ID选择器自由组合。</li>
</ul>
<h4 id="子代选择器">子代选择器</h4>
<p>示例：</p>
<pre><code class="language-css">div&gt;span {
    width: 100px;
    height: 100px;
    background-color: red;
}
</code></pre>
<p>特点：<br>
选中直接下一代元素，下下一代就选不中了。</p>
<h4 id="并集选择器">并集选择器</h4>
<p>示例：</p>
<pre><code class="language-css">div, span, .box {
    color: red;
}
</code></pre>
<p>特点：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端基础之认识前端]]></title>
        <id>https://tingke.github.io/post/e_CCmMcGI/</id>
        <link href="https://tingke.github.io/post/e_CCmMcGI/">
        </link>
        <updated>2020-07-04T08:39:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-什么是前端">1、什么是前端</h2>
<p>前端对于网站来说，通常是指网页，网站的前台部分包括网站的表现层和结构层。因此前端技术一般分为前端设计和前端开发。<br>
前端设计一般可以理解为网站的视觉设计，比如 UI 设计；<br>
前端开发则是网站的前台代码实现，包括基本的HTML和CSS以及JavaScript/ajax，现在最新的高级版本HTML5、CSS3，以及SVG等。<br>
前端开发的核心部分主要是：HTML，CSS，JavaScript 三个部分。<br>
HTML 是这三者中最基础的部分，相当于是网页的骨架，也就是网页的结构；<br>
CSS 部分是网页的表现形式，也可以说是网页的美化，比如一个图片的大小、位置，文字的大小颜色等；<br>
JavaScript 是一种动态的脚本语言，负责与用户进行交互，增加用户体验的作用。</p>
<h2 id="2-网页组成">2、网页组成</h2>
<p>一个网页的组成部分主要包括下面几个部分：文字、图片、输入框、视频、音频、超链接 等。</p>
<h2 id="3-web-标准">3、Web 标准</h2>
<p>说道 Web 标准，不能不说 W3C 组织（World Wide Web Consortium），全程为「万维网联盟」。万维网联盟创建于1994年，是Web技术领域最具权威和影响力的国际中立性技术标准机构。<br>
W3C 最重要的工作是发展 Web 规范（称为推荐，Recommendations），这些规范描述了 Web 的通信协议（比如 HTML 和 XHTML）和其他的构建模块。简单的说就是就是确定 Web 页面的语法格式和规范的。<br>
与之类似的一个组织是「European Computer Manufacturers Association」（ECMA组织），这个组织制定了标准的脚本语言规范 ECMAScript ，而 JavaScript 就参照的这个规范。<br>
那么 Web 标准规范了下面三个部分：</p>
<ul>
<li>HTML 标准（结构标准 ），相当人的骨架结构。</li>
<li>CSS 样式（表现）标准 ， 相当于给人化妆变的更漂亮。</li>
<li>JavaScript 行为标准 ， 相当与人在唱歌，页面更灵动。</li>
</ul>
<h2 id="4-浏览器内核">4、浏览器内核</h2>
<p>浏览器内核是一个浏览器的核心部分，也就是「渲染引擎」。它的主要作用是决定一个浏览器如何显示网页的内容及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同。<br>
这里涉及到一个「兼容性问题」，浏览器兼容性问题又被称为网页兼容性或网站兼容性问题，指网页在各种浏览器上的显示效果可能不一致而产生浏览器和网页间的兼容问题。所以我们在编写代码的时候，做好浏览器兼容，才能够让网站在不同的浏览器下都正常显示。而对于浏览器软件的开发和设计，浏览器对标准的更好兼容能够给用户更好的使用体验。</p>
<h2 id="5-认识-html">5、认识 HTML</h2>
<p><strong>HTML</strong> 全程为：超文本标记语言（Hyper Text Markup Language）。这里超文本就是超链接的意思，就是可以实现页面的跳转。</p>
<h2 id="6-html-结构标准">6、HTML 结构标准</h2>
<p>HTML 基本结构如下：</p>
<pre><code class="language-html">&lt; !doctype html&gt;    声明文档类型
&lt;html&gt; 根标签
    &lt;head&gt; 头标签
        &lt;title&gt;标题标签&lt;/title&gt; 
    &lt;/head&gt;
    &lt;body&gt;
        主体标签
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><code>&lt;!DOCTYPE html&gt;</code><br>
是告诉浏览器，以下文件用 HTML 哪个版本解析，这里是 HTML5 版本。</li>
<li><code>&lt;html&gt;&lt;/html&gt;</code> 标签是一个网页的根标签，所有的标签都要写在这一对根标签里面。</li>
<li><code>&lt;head&gt;&lt;/head&gt;</code> 是头标签，主要是定义文档（网页）的头部，包括完档的属性和信息，文档的标题，还可以引入 JavaScript 脚本，CSS 格式等。</li>
<li><code>&lt;body&gt;&lt;/body&gt;</code> 是一个文档的主题，里面包含文档的所有内容，比如文本，超链接，图片，表格等内容。</li>
</ul>
<h2 id="7-html-标签分类">7、html 标签分类</h2>
<p>单标签 <code>&lt;! Doctype html&gt;</code><br>
双标签 <code>&lt;html&gt; &lt;/html&gt;</code> ，<code>&lt;head&gt;&lt;/head&gt;</code>， <code>&lt;title&gt;&lt;/title&gt;</code></p>
<h2 id="8-html-标签关系分类">8、html 标签关系分类</h2>
<p>包含（嵌套关系）<code>&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;</code> 父子关系<br>
并列关系 <code>&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;</code> 兄弟姐妹</p>
<h2 id="9-开发工具">9、开发工具</h2>
<p>前期学习一种语言的时候，开发工具很重要。Web开发工具有很多。最简单的一个开发工具就是 Windows 系统自带的记事本了，但是又难用又难看，没有语法高亮、代码补全等功能。<br>
那么我推荐大家使用的是「vscode」 代码编辑器，它虽小巧精致，但有着炫酷的界面，并且有大量的插件可以使用，大大提高了代码的编写效率。<br>
提到 Web 开发工具不得不提到 JebBrain 全家桶的「 Webstorm 」软件。目前已经被广大 Web 开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。它令人称到的是它智能打代码补全、代码一键格式化、HTML 提示、联想查询、代码重构等强大功能。<br>
建议初学者初期使用Sublime等文本编辑器，太过于智能的编辑器确实会带给我们极大地便利，但是在带给我们便利的同时，也会削弱我们对基础知识的掌握，只有自己一个单词一个单词敲出来的代码，才会让我们记得更加牢固。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter 安装与入门]]></title>
        <id>https://tingke.github.io/post/flutter-an-zhuang-yu-ru-men/</id>
        <link href="https://tingke.github.io/post/flutter-an-zhuang-yu-ru-men/">
        </link>
        <updated>2019-09-01T00:49:08.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="flutter-入门">Flutter 入门</h1>
<h3 id="网站">网站：</h3>
<p>官方：https://flutter.io/docs/development/tools/ide/vs-code<br>
中文网：https://flutterchina.club/setup-macos/</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="flutter-入门">Flutter 入门</h1>
<h3 id="网站">网站：</h3>
<p>官方：https://flutter.io/docs/development/tools/ide/vs-code<br>
中文网：https://flutterchina.club/setup-macos/</p>
<!-- more -->
<h3 id="安装与配置">安装与配置：</h3>
<ol>
<li>
<p>下载Flutter</p>
<pre><code class="language-bash">cd ~
git clone -b master https://github.com/flutter/flutter.git
</code></pre>
</li>
<li>
<p>vscode 安装 Flutter 插件</p>
</li>
<li>
<p>本地配置路径</p>
<pre><code class="language-bash">vim ~/.zshrc
</code></pre>
<p>输入以下代码</p>
<pre><code>#for flutter by 2018-11-13
export PATH=/Users/kun/flutter/bin:$PATH	
export PUB_HOSTED_URL=https://dart-pub.mirrors.sjtug.sjtu.edu.cn
export FLUTTER_STORAGE_BASE_URL=https://mirrors.sjtug.sjtu.edu.cn
</code></pre>
</li>
<li>
<p>vscode 导入本地 Flutter SDK</p>
</li>
<li>
<p>cd 到 Flutter 根目录 运行 <code>flutter doctor</code> 安装相关包</p>
</li>
</ol>
<h3 id="简单命令">简单命令</h3>
<pre><code>flutter -h // 帮助

flutter create 【文件名称】 // 创建工程

flutter run // 运行,默认运行 lib/main.dart,如果 main 函数不 在main.dart 中需指定文件
</code></pre>
<h3 id="常用快捷键">常用快捷键</h3>
<pre><code>r 键：点击后热加载，也就算是重新加载吧。
R 键：点击后热重载，也就算是重新加载吧。
p 键：显示网格，这个可以很好的掌握布局情况，工作中很有用。
o 键：切换android和ios的预览模式。
q 键：退出调试预览模式。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS 四大布局]]></title>
        <id>https://tingke.github.io/post/css-si-da-bu-ju/</id>
        <link href="https://tingke.github.io/post/css-si-da-bu-ju/">
        </link>
        <updated>2019-07-08T13:47:22.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="css-四大布局">CSS 四大布局</h1>
<p>本文简单介绍 CSS 中的一些常见布局</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="css-四大布局">CSS 四大布局</h1>
<p>本文简单介绍 CSS 中的一些常见布局</p>
<!-- more -->
<h2 id="1-流式布局">1. 流式布局</h2>
<p>流式布局遵守标准文档流规则，通过CSS改变标签的display属性 block/inline-block。</p>
<p>HTML 中有 block 和 inline-block 两种标签，它们在流式布局中具有不同的表现：</p>
<ol>
<li>
<p>inline-block 标签可以嵌套在 block 标签中，反之则不可；</p>
</li>
<li>
<p>可以通过 display 修改标签属于 block 或者 inline-block 类型；</p>
</li>
<li>
<p>block 类型的标签布局是每一个标签独占一行，而 inline-block 标签会一个挨着一个进行布局；<br>
<img src="https://tingke.github.io//post-images/1562596159796.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="1"><img src="https://tingke.github.io//post-images/1562596197614.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h2 id="2-定位">2. 定位</h2>
<p>通过 position 的方式可以打破流式布局，它支持的值有：static，relative，absolute，fix 和 sticky。</p>
<ol>
<li>static：默认值，它遵循流水布局；</li>
<li>relative：相对布局，需要结合 top、bottom、left 和 right 配合使用，仅设置 position:relative 属性不管作用。它不会打破默认的布局的方式，只会在默认的布局方式发生偏移</li>
<li>absolute：绝对布局，这种布局方式会 使元素脱离原有的流式布局</li>
<li>fix：它的作用就是把某个元素固定到某个位置，比如把下面的标题「Web布局方式」始终固定到顶部，无论如何滑动都不会改变其位置。</li>
<li>sticky：它的作用是在某个位置固定某个元素的位置，比如滑动到某个位置后，让其固定。</li>
</ol>
<pre><code class="language-css">.div2 {
    /* 绝对定位:脱离标准文档流，相对父级元素位置定位 */
    background-color: blue;
    position: absolute;
    right: 50px;
    bottom: 50px;
}
.div3 {
    /* 固定定位:脱离标准文档流，固定于网页窗口位置定位 */
    background-color: green;
    position: fixed;
    left: 250px;
    top: 250px;
}
.div4 {
    background-color: green;
    /* 继承父级元素的定位属性 */
    position: inherit;  
    left: 250px;
    top: 250px;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://tingke.github.io//post-images/1562596209511.png" alt="" loading="lazy"></figure>
<h2 id="3-flexbox">3. Flexbox</h2>
<p>Flexbox 布局是通过 CSS 中的属性 display：flex 来控制的，布局时需要指定一个容器 flex container，然后把要布局的元素放到容器中，这些元素被称为 flex item</p>
<p>Flexbox 会把整个布局按两根轴（主轴（main axis），与主轴交叉的轴（cross axis））来布局。最外层为容器，容器内部为 item。整个布局思路就是按照不同的轴对 item 进行布局。</p>
<h3 id="flex相关属性">Flex相关属性：</h3>
<ol>
<li>flex-direction: 布局方向，决定子元素要按照什么方向进行布局，也就是「主轴」的方向。</li>
<li>flex-wrap: 定义子元素「超出」容器后该如何布局; no-wrap：可超出 | wrap：自动换行 | wrap-reverse：反向主轴排序自动换行</li>
<li>flex-flow: 为 flex-direction | flex-wrap 的复合</li>
<li>justify-content: 「主轴」的对齐方式；flex-start：左对齐 | flex-end：右对齐 | center：居中 | space-between：两端对齐，项目之间间隔相等 | space-around：项目两侧间隔相等，中间间隔是两边的2倍</li>
<li>align-items: 定义交叉轴的对齐方式; center：居中对齐 | flex-start：左对齐 | flex-end：右对齐 | stretch：拉伸 | baseline：基线</li>
<li>align-content: 如果存在多行，将对多行进行对齐，如果只有一行将不起作用，它会影响 align-items 的对齐方式；</li>
</ol>
<h3 id="flex-item相关属性">Flex-item相关属性：</h3>
<ol>
<li>order : 控制显示顺序，默认值为 0，可以设置负数和整数。值越小越往前排，值越大越往后排</li>
<li>flex-grow : 表示当容器存在「剩余空间」时，该如何分配剩余空间，默认值为 0，也就是说不会分配剩余空间</li>
<li>flex-shrink : 当容器空间不足时该如何缩小子元素，默认值为 1。如果设置为 0，即使容器空间不足，也不会缩小；</li>
<li>flex-basic ：它表示占用的最小空间，计算剩余空间会利用这个值来计算。</li>
<li>flex ：为 flex-grow, flex-shrink, flex-basic 的混合值，默认为0 1 auto；</li>
<li>align-self : 对齐方式，它默认继承自父元素的 align-items 值，可通过这个属性来修改这个值</li>
</ol>
<pre><code class="language-css">.container {
    display: flex;
    /* #
    row 主轴就是 X 轴的方向（默认）
    #row-reverse 主轴的相反方向
    #column 主轴方向为 Y 轴
    #column-reverse 主轴的相反方向 
    */
    flex-direction: column;
    text-align: center;
}
.container1 {
    display: flex;
    /* flex-wrap: 定义子元素「超出」容器后该如何布局; */
    flex-wrap: wrap;
    /* justify-content: 「主轴」的对齐方式； */
    justify-content: center;
    /* align-items: 定义交叉轴的对齐方式; */
}
.container1 div {
    /* width: 50px;
    height: 50px; */
    padding: 60px;
    background-color: blue;
    box-sizing: border-box;
    display: inline;
    margin: 10px;
}
.container1 div:nth-child(3) {
    background-color: red;
    order: 1;
    flex-grow: 1;
    align-self: center;
}
.footer {
    background-color: yellow;
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://tingke.github.io//post-images/1562596231416.png" alt="" loading="lazy"></figure>
<h2 id="4-grid">4. Grid</h2>
<p>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。</p>
<p>Flex 布局是轴线布局，只能指定&quot;项目&quot;针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成&quot;行&quot;和&quot;列&quot;，产生单元格，然后指定&quot;项目所在&quot;的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Code Review 机制和实施方案]]></title>
        <id>https://tingke.github.io/post/code-review-ji-zhi-he-shi-shi-fang-an/</id>
        <link href="https://tingke.github.io/post/code-review-ji-zhi-he-shi-shi-fang-an/">
        </link>
        <updated>2019-06-25T14:33:06.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="开展-review-的目的">开展 Review 的目的</h2>
<p>Code Review应该是软件工程最最有价值的一个活动。首先，我们先来看看Code Reivew的用处：</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="开展-review-的目的">开展 Review 的目的</h2>
<p>Code Review应该是软件工程最最有价值的一个活动。首先，我们先来看看Code Reivew的用处：</p>
<!-- more -->
<ol>
<li>Code reviews 中，可以通过大家的建议增进代码的质量。</li>
<li>Code reviews  是一个传递知识的手段，可以让其它并不熟悉代码的人知道作者的意图和想法，从而可以在以后轻松维护代码。</li>
<li>Code reviews 也鼓励程序员们相互学习对方的长处和优点。</li>
<li>Code reviews 也可以被用来确认自己的设计和实现是一个清楚和简单的。</li>
<li>Code reviews 不应该承担发现代码错误的职责。Code Review主要是审核代码的质量，如可读性，可维护性，以及程序的逻辑和对需求和设计的实现。代码中的bug和错误应该由单元测试，功能测试，性能测试，回归测试来保证的</li>
<li>Code reviews 不应该成为保证代码风格和编码标准的手段。编码风格和代码规范都属于死的东西，每个程序员在把自己的代码提交团队Review的时候，代码就应该是符合规范的，这是默认值，属于每个人自己的事情，不应该交由团队来完成，否则只会浪费大家本来就不够的时间。</li>
</ol>
<h2 id="code-review的原则">Code Review的原则</h2>
<ol>
<li>
<p>经常进行Code Review<br>
当你面对那近万行的代码，以前N多掺和在一起的功能，你会发现，整个Code Review变得非常地艰难，用不了一会儿，你就会发现大家都在拼命地打着哈欠，但还是要坚持，有时候，这样的Review会持续3个小时以上，相当的夸张。</p>
</li>
<li>
<p>Code Review不要太正式，而且要短<br>
只有不正式的Code Review才会让你和评审者放轻松，人只有放松了，才会表现得很真实，很真诚。记住Review只不过是一种形式，而只有在相互信任中通过相互的讨论得到了有意义和有建设性的建议和意见，那才是最实在的。</p>
</li>
<li>
<p>尽可能的让不同的人Review你的代码<br>
不同的人可以全面的从各个方面评论你的代码，有的从实现的角度，有的从需求的角度，有的从用户使用的角度，有的从算法的角度，有的从性能效率的角度，有的从易读的角度，有的从扩展性的角度……</p>
</li>
<li>
<p>保持积极的正面态度<br>
无论是代码作者，还是评审者，都需要一种积极向上的正面的态度，作者需要能够虚心接受别人的建议，因为别人的建议是为了让你做得更好；评审者也需要以一种积极的正面的态度向作者提意见，因为那是和你在一个战壕里的战友。记住，你不是一段代码，你是一个人！</p>
</li>
<li>
<p>学会享受Code Review<br>
如果你到了一个人人都喜欢Code Reivew的团阿，那么，你会进入到一个生机勃勃的地方，在那里，每个人都能写出质量非常好的代码，在那里，你不需要经理的管理，团队会自适应一切变化，他们相互学习，相互帮助，不仅仅是写出好的代码，而且团队和其中的每个人都会自动进化</p>
</li>
</ol>
<h2 id="如何开展code-review">如何开展Code Review</h2>
<p>目前业界运作CodeReview的方式有多种方式：强制&amp;非强制、线上交流&amp;线下会议、小片段&amp;大模块、事前&amp;事后、高频率&amp;低频率，等等……据了解，目前每种形态都有各自的市场，被不同的团队运用着。</p>
<p>接下来分析下各种形态的优缺点，供大家参考：</p>
<ol>
<li>
<p>强制&amp;非强制： 按照经验，CodeReview启动前期建议采用强制要求，否则很难有效开展起来。坚持一段时间待习惯养成后再考虑自由度。</p>
</li>
<li>
<p>小片段&amp;大模块：如果想要让问题暴露更充分或降低review的难度，建议采用细粒度方式进行，即小片段提交小片段review。如果更关注全局设计和逻辑思路的学习和找茬，那么可以用模块方式统一review。但很多时候这两种方式是可以结合运作的。</p>
</li>
<li>
<p>线上交流&amp;线下会议： 如果想提高效率，建议采用线上方式进行交流，这里要推荐公司的Code平台，上面支持CodeReview的功能都已经比较齐全。如果更喜欢全员一起找茬的那种快感，那么可以采用线下会议方式开展，但采用开会的方式，一般成本较高，可看团队接受度。</p>
</li>
<li>
<p>事前&amp;事后：这里指的是发布前还是发布后。版本发布后统一进行CodeReview的方式更多是一种代码交流活动， 起不到代码质量把关的作用。反之，如果在版本发布前就对代码进行CodeReview，就可以对质量问题起到很好的把关作用。这里是时间和质量之间的权衡。</p>
</li>
<li>
<p>高频率&amp;低频率：建议的是把代码交流放在每一天，所以频率越高越好。具体根据团队实际情况进行安排即可。</p>
</li>
<li>
<p>此外，也有团队采用模块owner把关质量的CodeReview方式，这种更多是从质量风险规避角度上考虑，在代码提交前owner检查是否有质量问题，确认没有问题后方能发布，有这方面需要的团队也可以考虑这种方式。</p>
</li>
</ol>
<h2 id="代码审查清单">代码审查清单</h2>
<h3 id="设计常规项">设计常规项</h3>
<ol>
<li>设计是否合理符合通常设计模式，</li>
<li>逻辑是否考虑闭环全面考虑</li>
<li>扩展性是否考虑</li>
<li>是否存在安全漏洞</li>
</ol>
<h3 id="编码常规项">编码常规项</h3>
<ol>
<li>代码是否内存泄漏，是否UI成红色，是否性能低下，是否会形成crash</li>
<li>各种异常逻辑是否处理</li>
<li>代码能够工作么？它有没有实现预期的功能，逻辑是否正确等。</li>
<li>所有的代码是否简单易懂？</li>
<li>代码符合你所遵循的编程规范么？这通常包括大括号的位置，变量名和函数名，行的长度，缩进，格式和注释。</li>
<li>是否存在多余的或是重复的代码？</li>
<li>代码是否尽可能的模块化了？</li>
<li>是否有可以被替换的全局变量？</li>
<li>是否有被注释掉的代码？</li>
<li>循环是否设置了长度和正确的终止条件？</li>
<li>是否有可以被库函数替代的代码？</li>
<li>是否有可以删除的日志或调试代码？</li>
</ol>
<h3 id="安全">安全</h3>
<ol>
<li>所有的数据输入是否都进行了检查（检测正确的类型，长度，格式和范围）并且进行了编码？</li>
<li>在哪里使用了第三方工具，返回的错误是否被捕获？</li>
<li>输出的值是否进行了检查并且编码？</li>
<li>无效的参数值是否能够处理？</li>
</ol>
<h3 id="文档">文档</h3>
<ol>
<li>是否有注释，并且描述了代码的意图？</li>
<li>所有的函数都有注释吗？</li>
<li>对非常规行为和边界情况处理是否有描述？</li>
<li>第三方库的使用和函数是否有文档？</li>
<li>数据结构和计量单位是否进行了解释？</li>
<li>是否有未完成的代码？如果是的话，是不是应该移除，或者用合适的标记进行标记比如‘TODO’？</li>
</ol>
<h3 id="测试">测试</h3>
<ol>
<li>代码是否可以测试？比如，不要添加太多的或是隐藏的依赖关系，不能够初始化对象，测试框架可以使用方法等。</li>
<li>是否存在测试，它们是否可以被理解？比如，至少达到你满意的代码覆盖(code coverage)。</li>
<li>单元测试是否真正的测试了代码是否可以完成预期的功能？</li>
<li>是否检查了数组的“越界“错误？</li>
<li>是否有可以被已经存在的API所替代的测试代码？</li>
</ol>
<p>参考阅读：</p>
<ol>
<li><a href="https://segmentfault.com/a/1190000003967247">为什么要坚持code review</a></li>
<li><a href="https://www.imooc.com/article/details/id/2991">Code Review 不知道什么时候你会进行到这一步？</a></li>
<li><a href="https://segmentfault.com/a/1190000016155779">基于GitLab的Code Review教程</a></li>
<li><a href="https://my.oschina.net/powertoolsteam/blog/1928077">这四类Code Review方法你都知道吗？</a></li>
<li><a href="https://blog.csdn.net/fishmai/article/details/78651521">代码review总结</a></li>
<li><a href="https://gitee.com/douyadg/FE-Standard">我们的代码规范</a></li>
<li><a href="https://github.com/ecomfe/spec">百度的代码规范</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FileMerge的基本使用]]></title>
        <id>https://tingke.github.io/post/filemerge-de-ji-ben-shi-yong/</id>
        <link href="https://tingke.github.io/post/filemerge-de-ji-ben-shi-yong/">
        </link>
        <updated>2018-09-13T13:54:41.000Z</updated>
        <summary type="html"><![CDATA[<p>作为一个开放人员，比较代码和合并代码是常有的事，以前都是用Beyond Compare这软件来比较的，后面发现Xcode自带的FileMerge也挺好用的，还省的多下载一个软件。下面我将介绍下 XCode自带的FileMerge进行代码合并管理的使用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>作为一个开放人员，比较代码和合并代码是常有的事，以前都是用Beyond Compare这软件来比较的，后面发现Xcode自带的FileMerge也挺好用的，还省的多下载一个软件。下面我将介绍下 XCode自带的FileMerge进行代码合并管理的使用。</p>
<!-- more -->
<p>首先。FileMerge是XCode 4.x 自带的一个管理代码合并的工具，在XCode中如果提交svn 或者 git的时候，在展示diff的时候，其实就用到了这个工具的部分功能。</p>
<p>首先FileMerge，不仅仅只是支持Compare，还能很好的支持merge。而merge是我们管理代码的时候经常性遇到的基础需求。废话少说。下面展示下FileMerge怎么使用</p>
<p>FileMerge 在 XCode的安装目录可以找到。如下图路径</p>
<figure data-type="image" tabindex="1"><img src="http://outiw4np3.bkt.clouddn.com/3edd23c52c074e1e0e87d2763db7f945.jpg" alt="" loading="lazy"></figure>
<p>打开应用后界面如下图：<br>
<img src="http://outiw4np3.bkt.clouddn.com/6374cf0895f1c5b0da7c5be1af19c138.jpg" alt="" loading="lazy"></p>
<p>界面很简单，接下来就是设置Left ，Right。Left Right就是你要比较的项目的根目录。请记住你Left 和 RIght。这个在接下来的操作中非常重要。好了，点击 Compare 进入</p>
<p>经过比较，灰色为完全相同的文件，黑色表示有不同之处的文件<br>
<img src="http://outiw4np3.bkt.clouddn.com/cc7fd60fc0125f56722414ee1fe366a1.jpg" alt="" loading="lazy"></p>
<p>使用Comparison打开文件<br>
<img src="http://outiw4np3.bkt.clouddn.com/34c75426999338eb957f71cea52a17ba.jpg" alt="" loading="lazy"><br>
<img src="http://outiw4np3.bkt.clouddn.com/468790cb7817aa7da408aac59e6e8e0b.jpg" alt="" loading="lazy"></p>
<p>FileMerge是需要等你处理了所有不同处的Actions 以后，在关闭这个界面，回到上一层的时候。看到View 选项下面有 Merge 选项。Combine Filles 其实就是相当于应用你保存的Actions并合并代码。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《图解HTTP》读书笔记]]></title>
        <id>https://tingke.github.io/post/lesslesstu-jie-httpgreatergreater-du-shu-bi-ji/</id>
        <link href="https://tingke.github.io/post/lesslesstu-jie-httpgreatergreater-du-shu-bi-ji/">
        </link>
        <updated>2018-06-29T12:00:40.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="tcpip-协议族分层">TCP/IP 协议族分层</h2>
<ol>
<li>应用层
<ul>
<li>向用户提供应用服务，如：<code>HTTP（HyperText Transfer Protocol，超文本传输协议）</code>、<code>FTP（File Transfer Protocol，文件传输协议）</code>、<code>DNS（Domain Name System，域名系统）</code>等</li>
</ul>
</li>
<li>传输层
<ul>
<li>为应用层提供处于网络连接中的客户端和服务端的数据传输，如 TCP<code>（Transmission Control Protocol，传输控制协议）</code>、UDP<code>（User Data Protocol，用户数据报协议）</code></li>
</ul>
</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h2 id="tcpip-协议族分层">TCP/IP 协议族分层</h2>
<ol>
<li>应用层
<ul>
<li>向用户提供应用服务，如：<code>HTTP（HyperText Transfer Protocol，超文本传输协议）</code>、<code>FTP（File Transfer Protocol，文件传输协议）</code>、<code>DNS（Domain Name System，域名系统）</code>等</li>
</ul>
</li>
<li>传输层
<ul>
<li>为应用层提供处于网络连接中的客户端和服务端的数据传输，如 TCP<code>（Transmission Control Protocol，传输控制协议）</code>、UDP<code>（User Data Protocol，用户数据报协议）</code></li>
</ul>
</li>
</ol>
<!-- more -->
<ol start="3">
<li>网络层
<ul>
<li>用来处理在网络上流动的数据包，为数据包的传输选择一条传输线路，如：<code>IP（Internet Protocol，网际协议）</code></li>
</ul>
</li>
<li>数据链路层
<ul>
<li>处理连接网络的硬件部分，如：光纤、网卡、驱动等</li>
</ul>
</li>
</ol>
<p>传输图解<br>
<img src="http://outiw4np3.bkt.clouddn.com/15e41c7da0dd411dabdbbad1266da079.jpg" alt="" loading="lazy"></p>
<h2 id="与-http-紧密相连的tcpip-协议族">与 HTTP 紧密相连的TCP/IP 协议族</h2>
<h3 id="负责传输的-ip-协议">负责传输的 IP 协议</h3>
<p>“IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。</p>
<p>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。”</p>
<h3 id="确保可靠性的-tcp-协议">确保可靠性的 TCP 协议</h3>
<p>“为了准确无误地将数据送达目标处，TCP 协议采用了<strong>三次握手</strong>（three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）”<br>
<img src="http://outiw4np3.bkt.clouddn.com/757742571edfeb7cf1146efeed251d2f.jpg" alt="" loading="lazy"></p>
<p>TCP 为什么是三次握手，不是两次或四次呢？</p>
<pre><code>三次握手：
“喂，你听得到吗？”
“我听得到呀，你听得到我吗？”
“我能听到你，今天balabala……”

两次握手：
“喂，你听得到吗？”
“我听得到呀”
“喂喂，你听得到吗？”
“草，我听得到呀！！！！”
“你TM能不能听到我讲话啊！！喂！”
“……”

四次握手：
“喂，你听得到吗？”
“我听得到呀，你听得到我吗？”
“我能听到你，你能听到我吗？”
“……不想跟傻逼说话”

--来自知乎的段子
</code></pre>
<p>可以看出四次握手显得过于庸余，而两次握手并不能确定双方的链接稳定了。</p>
<h3 id="负责域名解析的-dns-协议">负责域名解析的 DNS 协议</h3>
<p>计算机善于处理长串数字，但不容易理解名称；用户善于记忆名称，而不习惯记忆长串数字，于是 DNS 协议应运而生。</p>
<blockquote>
<p>“DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务”</p>
</blockquote>
<h3 id="http-与-dnstcpip-关系图">HTTP 与 DNS/TCP/IP 关系图</h3>
<figure data-type="image" tabindex="1"><img src="http://outiw4np3.bkt.clouddn.com/8cfb742e225135a59dde1c57682acd95.jpg" alt="" loading="lazy"></figure>
<h3 id="uri-和-url">URI 和 URL</h3>
<p>URI:（Uniform Resource Identifier，统一资源标识符）<br>
URL：(Uniform Resource Locator，统一资源定位符）</p>
<p>URI基本格式：<br>
<img src="http://outiw4np3.bkt.clouddn.com/bb1889fcf7a8d59ac92c161190334370.jpg" alt="" loading="lazy"></p>
<p>协议方案：获取访问资源时要指定协议类型，如ftp、https等<br>
登录信息：指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）<font color='red'>可选</font><br>
片段标识：使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）</p>
<h2 id="http-协议">HTTP 协议</h2>
<p>一个 HTTP 协议必定有两端，请求访问资源的一端为客户端，提供资源响应的一端为服务器端，并且 HTTP 协议能明确区分哪是客户端哪是服务器端。</p>
<p>下面是从客户端发送给某服务器的请求报文<br>
<img src="http://outiw4np3.bkt.clouddn.com/2baf0cb2cca193520fbb5bb85de31ab8.jpg" alt="" loading="lazy"></p>
<p><code>GET</code> 表示访问服务器的类型，俗称“方法”<br>
<code>//feed/v1/feed/get_attention_list?...uid=</code> 指明了访问的资源对象，也叫做“URI”<br>
<code>HTTP/1.1</code> 及 HTTP 的版本号，用来提示客户端使用的http协议功能</p>
<figure data-type="image" tabindex="2"><img src="http://outiw4np3.bkt.clouddn.com/297363515632a28a51650e64c6a68d56.jpg" alt="" loading="lazy"></figure>
<p><strong>请求报文</strong>是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。</p>
<figure data-type="image" tabindex="3"><img src="http://outiw4np3.bkt.clouddn.com/68e6c6b31aadffeada3e2b572230a0c1.jpg" alt="" loading="lazy"></figure>
<p><strong>响应报文</strong>基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成</p>
<figure data-type="image" tabindex="4"><img src="http://outiw4np3.bkt.clouddn.com/54322dbb9d6225627c4c19a9fc48b1dd.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>“HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理”</p>
<p>“HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了”</p>
</blockquote>
<h3 id="http-方法">HTTP 方法</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取资源</td>
</tr>
<tr>
<td>POST</td>
<td>传输实体的主体</td>
</tr>
<tr>
<td>PUT</td>
<td>传输文件</td>
</tr>
<tr>
<td>HEAD</td>
<td>获取报文首部</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>查询支持的方法</td>
</tr>
<tr>
<td>TRACE</td>
<td>追踪路径</td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求用隧道协议连接代理</td>
</tr>
</tbody>
</table>
<p><strong>方法名区分大小写，请注意要用大写字母</strong></p>
<h3 id="持久连接">持久连接</h3>
<p>“持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了”</p>
<p>“持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求”</p>
<h3 id="cookie-的状态管理">Cookie 的状态管理</h3>
<p>“Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态”</p>
<figure data-type="image" tabindex="5"><img src="http://outiw4np3.bkt.clouddn.com/cb588f16318cb814154c878fcbe44a0c.jpg" alt="" loading="lazy"></figure>
<h2 id="http-报文内的-http-信息">HTTP 报文内的 HTTP 信息</h2>
<p>用于 HTTP 协议交互的信息被称为 HTTP 报文。</p>
<h4 id="http-报文结构">HTTP 报文结构</h4>
<figure data-type="image" tabindex="6"><img src="http://outiw4np3.bkt.clouddn.com/7ce8b40311ecd74a53337a4e80fb762f.jpg" alt="" loading="lazy"></figure>
<h4 id="http-首部字段">HTTP 首部字段</h4>
<ol>
<li>
<p>通用首部字段</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一揽</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>请求首部字段</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>响应首部字段</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>实体首部字段</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ol>
<h4 id="http-返回的状态码">HTTP 返回的状态码</h4>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>2XX</td>
<td>表明请求被正常处理</td>
</tr>
<tr>
<td>200</td>
<td>“表示从客户端发来的请求在服务器端被正常处理”</td>
</tr>
<tr>
<td>204</td>
<td>“代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分”</td>
</tr>
<tr>
<td>206</td>
<td>“表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容”</td>
</tr>
<tr>
<td>3XX</td>
<td>表明浏览器需要执行某些特殊的处理以正确处理请求</td>
</tr>
<tr>
<td>301</td>
<td>“永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI”</td>
</tr>
<tr>
<td>302</td>
<td>“临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问”</td>
</tr>
<tr>
<td>303</td>
<td>“由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。”</td>
</tr>
<tr>
<td>304</td>
<td>“表示客户端发送附带条件的请求 2 时，服务器端允许请求访问资源，但未满足条件的情况”</td>
</tr>
<tr>
<td>307</td>
<td>“临时重定向。该状态码与 302 Found 有着相同的含义。”</td>
</tr>
<tr>
<td>4XX</td>
<td>“表明客户端是发生错误的原因所在。”</td>
</tr>
<tr>
<td>400</td>
<td>“该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求”</td>
</tr>
<tr>
<td>401</td>
<td>“该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息”</td>
</tr>
<tr>
<td>403</td>
<td>“该状态码表明对请求资源的访问被服务器拒绝了”</td>
</tr>
<tr>
<td>5XX</td>
<td>“表明服务器本身发生错误”</td>
</tr>
<tr>
<td>500</td>
<td>“该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障”</td>
</tr>
<tr>
<td>503</td>
<td>“表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求”</td>
</tr>
</tbody>
</table>
<h2 id="http-的缺点">HTTP 的缺点</h2>
<p>HTTP 主要有这些不足，例举如下。</p>
<ul>
<li>
<p>通信使用明文（不加密），内容可能会被窃听</p>
</li>
<li>
<p>不验证通信方的身份，因此有可能遭遇伪装</p>
</li>
<li>
<p>无法证明报文的完整性，所以有可能已遭篡改</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[被苹果弃用的PCH]]></title>
        <id>https://tingke.github.io/post/bei-ping-guo-qi-yong-de-pch/</id>
        <link href="https://tingke.github.io/post/bei-ping-guo-qi-yong-de-pch/">
        </link>
        <updated>2018-05-29T12:00:03.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="pch是什么">PCH是什么？</h4>
<p><code>PCH</code>是苹果为了提高编译速度引入的一个预编译文件，它所引用的内容能够被项目中的其他文件共享和访问，预编译后的头文件会被缓存起来，再次编译的时候就不需要重新编译 <code>PCH</code> 文件中导入的内容，从而提高编译速度。在Xcode6以前，新增的工程中会自动生成 “工程名-Prefix.pch”文件。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="pch是什么">PCH是什么？</h4>
<p><code>PCH</code>是苹果为了提高编译速度引入的一个预编译文件，它所引用的内容能够被项目中的其他文件共享和访问，预编译后的头文件会被缓存起来，再次编译的时候就不需要重新编译 <code>PCH</code> 文件中导入的内容，从而提高编译速度。在Xcode6以前，新增的工程中会自动生成 “工程名-Prefix.pch”文件。</p>
<!-- more -->
<p>相信很多iOS开发者都使用 <code>PCH</code> 文件做过以下一些事：</p>
<ol>
<li>存放一些宏定义</li>
<li>引入全局使用的头文件</li>
<li>开关日志打印</li>
</ol>
<p>这样的在编码的时候，不用在不同文件中不停的做引用，编写代码的速度简直快的飞起😂😂。</p>
<h4 id="这么爽的编码体验苹果为什么放弃主动引入pch">这么爽的编码体验，苹果为什么放弃主动引入PCH？</h4>
<p>正是iOS开发者的滥用 <code>PCH</code> 文件，造成项目编译缓慢，影响用户体验，与苹果当初引入 <code>PCH</code> 的目的背道而驰了，因此苹果不得不放弃 <code>PCH</code> 的使用。</p>
<p>我想，罪魁祸首就是开发者大量引入共用性不高的宏定义和头文件，每次修改引入内容造成 PCH的重编译；编译的时候整个工程范围地查找和替换这些宏定义字段，重复导入这些头文件，不慢就奇怪了。</p>
<h4 id="正确的使用方式">正确的使用方式</h4>
<ol>
<li>不要把所有的宏定义都放到平常文件中，尤其是共用性较小的宏定义;</li>
<li>将公用性高的头文件放到 <code>PCH</code> 中，比如<code>Fundation框架</code>等</li>
<li>将零散的宏定义专门创建一个头文件来放置，再导入到 <code>PCH</code> 中，方便查看和修改</li>
</ol>
<p>其实，过分依赖 <code>PCH</code> 文件也有一些问题：它降低了代码的可移植性。把类中使用的框架等放在 <code>PCH</code> 中，要么你要重新去导入，要么把 <code>PCH</code> 一同拖走，还要删掉没用的代码，代价也是蛮大的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue.js入门]]></title>
        <id>https://tingke.github.io/post/vuejs-ru-men/</id>
        <link href="https://tingke.github.io/post/vuejs-ru-men/">
        </link>
        <updated>2018-03-23T07:00:14.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="vuejs是什么">Vue.js是什么</h2>
<blockquote>
<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的<font color='red'><strong>渐进式框架</strong></font>。与其它大型框架不同的是，Vue 被设计为可以<font color='red'><strong>自底向上逐层应用</strong></font>。Vue 的核心库只关注<font color='red'><strong>视图层</strong></font>，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="vuejs是什么">Vue.js是什么</h2>
<blockquote>
<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的<font color='red'><strong>渐进式框架</strong></font>。与其它大型框架不同的是，Vue 被设计为可以<font color='red'><strong>自底向上逐层应用</strong></font>。Vue 的核心库只关注<font color='red'><strong>视图层</strong></font>，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
</blockquote>
<!-- more --> 
<p>官方网站：<a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></p>
<h2 id="安装">安装</h2>
<ol>
<li>
<p><strong>引入Vue.js环境</strong></p>
<p>你可以创建一个 <code>.html</code> 文件，然后通过如下方式引入 <strong>Vue</strong>：</p>
<pre><code class="language-html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li>
<p><strong>NPM</strong><br>
在用 <strong>Vue</strong> 构建大型应用时推荐使用 NPM 安装[1]。NPM 能很好地和诸如 webpack 或 Browserify 模块打包器配合使用。同时 Vue 也提供配套工具来开发单文件组件。</p>
<pre><code class="language-sh">$ npm install vue
</code></pre>
</li>
<li>
<p><strong>命令行工具（CLI）</strong><br>
Vue 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具为现代化的前端开发工作流提供了开箱即用的构建配置。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：</p>
<pre><code class="language-sh"># 全局安装 vue-clir
$ npm install --global vue-cli
# 创建一个基于 webpack 模板的新项目
$ vue init webpack my-project
# 安装依赖，走你
$ cd my-project
$ npm run dev

</code></pre>
<blockquote>
<p>[warning]<br>
CLI 工具假定用户对 Node.js 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下通读指南，在熟悉 Vue 本身之后再使用 CLI。</p>
</blockquote>
</li>
</ol>
<h2 id="vue实例">Vue实例</h2>
<p>每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的：</p>
<pre><code class="language-js">var vm = new Vue({
  // 选项
})
</code></pre>
<h3 id="常用选项">常用选项</h3>
<p><code>el</code>:提供一个在页面上已存在的 <code>DOM</code> 元素作为 <code>Vue</code> 实例的挂载目标。可以是 <code>CSS</code> 选择器，也可以是一个 <code>HTMLElement</code> 实例。</p>
<p><code>data</code>: Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问。</p>
<pre><code class="language-html">&lt;body&gt;
    &lt;h1&gt;vue-component组件&lt;/h1&gt;
    &lt;hr&gt;
    &lt;div id=&quot;app&quot;&gt;
        {{ msg }}&lt;br&gt;
        &lt;a href=&quot;#&quot;&gt;我是tingke&lt;/a&gt;'
    &lt;/div&gt;
    &lt;div id=&quot;app1&quot;&gt;
        &lt;a href=&quot;#&quot;&gt;我是{{msg}}&lt;/a&gt;'
    &lt;/div&gt;

    &lt;script&gt;
        var app = new Vue({
            el: '#app',
            data: {
                msg: '123'
            },
        });
        var app1 = new Vue({
            el: '#app1',
            data:{
                msg: '321'
            }
        });
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p><code>methods</code>: 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。</p>
<p><code>computed</code>:计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。</p>
<pre><code class="language-js">var app =new Vue({
    el: '#app',
    data: {
        cash: 100,
        newsList:[
            {title:'香港或就“装甲车被扣”事件追责 起诉涉事运输公司',date:'2017/3/10'},
            {title:'日本第二大准航母服役 外媒：针对中国潜艇',date:'2017/3/12'},
            {title:'中国北方将有明显雨雪降温天气 南方阴雨持续',date:'2017/3/13'},
            {title:'起底“最短命副市长”：不到40天落马，全家被查',date:'2017/3/23'},
        ]
    },
    computed: {
        money: function () {
            return  '￥' + this.cash + '元';
        },
        list: function () {
            var arr = this.newsList.slice();
            return arr.reverse();
        }
    }
})
</code></pre>
<p><code>watch</code>:一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 <code>watch</code> 对象的每一个属性。</p>
<pre><code class="language-js">var suggestion=['T恤短袖','夹克长裙','棉衣羽绒服'];
var app =new Vue({
    el: '#app',
    data:{
        temperature:14,
        suggestion:'夹克长裙'
    },
    methods:{
        add:function(){
            this.temperature+=5;
        },
        reduce:function(){
            this.temperature-=5;
        }
    },
    watch:{
        // 监听温度，【注意】不应该使用箭头函数来定义 watcher 函数
        temperature:function(newVal,oldVal){
            if(newVal&gt;=26) {
                this.suggestion=suggestion[0];
            }else if(newVal&lt;26 &amp;&amp; newVal &gt;=0) {
                this.suggestion=suggestion[1];
            }else {
                this.suggestion=suggestion[2];
            }
        }
    }
});
</code></pre>
<h3 id="实例生命周期钩子">实例生命周期钩子</h3>
<p><code>beforeCreate</code>:在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p>
<p><code>creaated</code>:在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前不可见。</p>
<p><code>beforeMount</code>:在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。<br>
<code>mounted</code>:<code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p>
<p><code>beforeUpdate</code>: 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p>
<p><code>updated</code>:由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子</p>
<p><code>beforeDestroy</code>:实例销毁之前调用。在这一步，实例仍然完全可用</p>
<p><code>destroyed</code>:Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
<figure data-type="image" tabindex="1"><img src="https://cn.vuejs.org/images/lifecycle.png" alt="" loading="lazy"></figure>
<h2 id="指令">指令</h2>
<h3 id="基本介绍">基本介绍</h3>
<ol>
<li>
<p><strong>v-text</strong>：主要用于文本的渲染。和 <code>{{ Mustache }}</code> 功能一样。但是 <code>{{ Mustache }}</code> 在第一次页面Vue木有初始化完成会显示 <code>{{ Mustache }}</code> 字符。故文本渲染多用v-text。</p>
<pre><code class="language-html">&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;
&lt;!-- 和下面的一样 --&gt;
&lt;span&gt;{{msg}}&lt;/span&gt;
</code></pre>
<blockquote>
<p>[info] 如果遇到更新部分的 <code>textContent</code> ，需要使用 <code>{{ Mustache }}</code> 插值。</p>
</blockquote>
</li>
<li>
<p><strong>v-html</strong>：更新元素的 <code>innerHTML</code> 。注意：内容按普通 <code>HTML</code> 插入 - 不会作为 Vue 模板进行编译 。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。</p>
</li>
<li>
<p><strong>v-model</strong>:主要是在表单里面使用。比如文本框、下拉框、单选、复选、textarea。v-model是一个双向的功能。文本框输入以后，模型也会发生改变。反之模型改变了文本框也会改变。</p>
</li>
<li>
<p><strong>v-show</strong>：控制显示隐藏。dom是存在的。仅仅加 display block, display none。</p>
<blockquote>
<p>[warning] 注意，v-show 不支持 <code>&lt;template&gt;</code> 元素，也不支持 v-else。</p>
</blockquote>
</li>
<li>
<p><strong>v-if</strong>：控制显示隐藏。如果dom不显示，整个dom没有不存在。</p>
</li>
<li>
<p><strong>v-bind</strong>：绑定属性。给一个dom元素添加属性。【比如：在做图片的渲染过程中，如果图片的src地址是动态的，那么就需要v-bind去绑定src属性，去给这个src赋值。】。凡是样式变化的可能用v-bind动态去操作class 【不要在原生的class里面去使用 <code>{{ Mustache }}</code> 改变class】</p>
</li>
<li>
<p><strong>v-for</strong>：循环。主要用于表格，<code>&lt;li&gt;</code> 标签去循环一个数组。【凡是看到列表就要v-for】</p>
</li>
<li>
<p><strong>v-on</strong>：事件绑定。【v-on：同等于@】，用于需要人机操作交互的地方</p>
</li>
<li>
<p><strong>v-cloak</strong>：这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。<br>
在使用 HTML 绑定 Vue实例时，在页面加载时会闪烁。为了效果更明显，我们可以延后加载 Vue 实例。</p>
<pre><code class="language-js">setTimeout(() =&gt; {
    new Vue({
        el: '#app',
        data: {
            msg: 'hello'
        }
    })
},2000)
</code></pre>
<p>而 v-cloak 可以解决这一问题，在 css 中加上</p>
<pre><code class="language-js">[v-cloak] {
  display: none;
}
</code></pre>
<p>此时，页面会在实例编译完成后显示。</p>
</li>
<li>
<p><strong>v-pre</strong>：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p>
<pre><code class="language-html">&lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt;
</code></pre>
</li>
<li>
<p><strong>v-once</strong>：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p>
<pre><code class="language-html">&lt;div v-once&gt;
  &lt;h1&gt;comment&lt;/h1&gt;
  &lt;p&gt;{{msg}}&lt;/p&gt;
&lt;/div&gt;
</code></pre>
</li>
</ol>
<h3 id="常见问题">常见问题</h3>
<ol>
<li>
<p>v-if与v-show区别？</p>
<p>v-if 是'真正的'条件渲染,因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建.</p>
<p>v-if 也是惰性的,如果在初始渲染时条件为假，那么什么都不做，直到条件第一次为真的时候才会开始渲染条件块。</p>
<p>相比之下，v-show 就简单得多</p>
<p>不管初始条件是什么,元素总会被渲染,并且只是简单的基于 css 进行切换 display 属性.</p>
<p>一般来说,v-if 有更高的切换开销,而 v-show 有更高的出事渲染开销.因此,如果需要非常频繁的切换,那么使用 v-show 好一点;如果在</p>
<p>运行时条件不太可能改变,则使用 v-if 好点.</p>
<p>注意，v-show 不支持 <code>&lt;template&gt;</code> 元素，也不支持 v-else。</p>
</li>
<li>
<p>为什么我用的 v-cloak 无效？</p>
<p>在实际项目中，我们常通过 @import 来加载 css 文件</p>
<pre><code>@import &quot;style.css&quot;

@import &quot;index.css&quot;
</code></pre>
<p>而 @import 是在页面 DOM 完全载入后才会进行加载，如果我们将 [v-cloak] 写在 @import 加载的 css 文件中，就会导致页面仍旧闪烁。</p>
<p>为了避免这种情况，我们可以将 [v-cloak] 写在 link 引入的 css 中，或者写一个内联 css 样式，这样就得到了解决。</p>
</li>
</ol>
<h2 id="其他问题">其他问题</h2>
<ol>
<li>
<p>什么是字符串模板？什么是HTML模板？</p>
<figure data-type="image" tabindex="2"><img src="http://outiw4np3.bkt.clouddn.com/94b524f73f9c0afd8bb88bf1b14c0d25.jpg" alt="123" loading="lazy"></figure>
<blockquote>
<p>你写在html中的 就是非字符串模板。你写在js中的 template:&quot;&quot;,这个就是字符串 模板</p>
</blockquote>
</li>
</ol>
]]></content>
    </entry>
</feed>