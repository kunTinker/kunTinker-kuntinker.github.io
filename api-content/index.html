{"posts":[{"title":"前端基础之CSS属性","content":"前面介绍了CSS的选择器，既然选择了正确的标签，我们该如何改变标签的样式呢？ 0x00 文本元素 1、属性 font-size: 50px; /*文字大小*/ font-weight: 700; /*值从100-900，文字粗细,700约等于Bold，不推荐使用font-weight:bold; */ font-family:微软雅黑; /*文本的字体*/ font-style: normal | italic; /*normal:默认值 italic:斜体*/ line-height: 50px; /*行高*/ 2、文本属性连写 /* 格式：font: font-style font-weight font-size/line-height font-family; */ font: italic 700 50px/40px 微软雅黑; 注意：font:后边写属性的值。一定按照书写顺序。 PS：文本属性连写中文字大小和字体为必写项。 3、文字的表达方式 font-family: 微软雅黑; // 直接写中文名称 font-family: microsoft yahei; // 写字体的英文名称 font-family: \\5FAE\\8F6F\\96C5\\9ED1; // unicode 编码（解析更快） ","link":"https://tingke.github.io/post/iZ7sJPRIL/"},{"title":"前端基础之CSS选择器","content":"0x00 简单认识CSS 1、什么是 CSS？ CSS 全称为 Cascading Style Sheets，中文翻译为“层叠样式表”，简称 CSS 样式表，所以称之为层叠样式表（Cascading Stylesheet）简称 CSS。在网页制作时采用 CSS 技术，可以有效地对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制。只要对相应的代码做一些简单的修改，就可以改变同一页面的不同部分，或者页数不同的网页的外观和格式。 2、CSS 的作用 简单地来讲，CSS 能对你制作的网页进行布局、颜色、背景、宽度、高度、字体进行控制，让网页按您的美工设计布局的更加美观漂亮。 样式是用来控制页面外观、设置元素对象属性的工具，使用样式可使页面产生各种特殊的效果。 3、样式表书写位置 &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* 样式表内容 */ &lt;/style&gt; &lt;/head&gt; 0x01 选择器 什么是选择器？ 选择器是一个选择标签的过程。 以下选择器会选取这个示例中出现举例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div{ font-size: 50px; color: red } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;等你下课&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;我是一个box&lt;/div&gt; &lt;div id=&quot;box&quot;&gt;我也是一个box&lt;/div&gt; &lt;div&gt;&lt;div class=&quot;box&quot;&gt;大家都是box&lt;/div&gt;&lt;/div&gt; &lt;div&gt;我是谁？&lt;span&gt;我在哪？&lt;/span&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 基础选择器 标签选择器 示例： div { width: 100px; } 特点： 标签选择器定义之后，会将页面所有的元素都执行这个标签样式。 类选择器（重点） 示例： .box { width: 100px; height: 100px; background-color: red; } 特点： 一个标签可以调用多个类选择器。多个标签可以调用同一个类选择器。 类选择器命名规则 不能用纯数字或者数字开头来定义类名； 不能使用特殊符号或者特殊符号开头（_ 除外）来定义类名； 不建议使用汉字来定义类名； 不推荐使用属性或者属性的值来定义类名。 类选择器常用的命名 header：头部 content/contrainer：内容 footer：底部 nav：导航栏 sidebar：侧边栏 wrapper：外围包装 left：左 right：右 center：中 loginbar：登录条 logo：标志 banner：广告 main：主体 hot：热点 copyright：版权 ID选择器 示例： #box { width: 100px; height: 100px; background-color: red; } 特点： 一个 ID 选择器在一个页面只能使用一次。如果使用2次或者2次以上，不符合 w3c 规范，JS 调用会出问题。 一个标签只能使用一个 ID 选择器。 一个标签可以同时使用类选择器和 ID 选择器。 通配符选择器 示例： * { color: #000; margin: 0; padding: 0; } 特点： 给所有的标签都使用相同的样式。 PS：★不推荐使用，增加浏览器和服务器负担。 复合选择器 两个或者两个以上的基础选择器通过不同的方式连接在一起。 交集选择器 示例： div.box { width: 100px; height: 100px; background-color: red; } 特点： 即要满足使用了某个标签，还要满足使用了类选择器或者ID选择器。 后代选择器（重点） 示例： div span { width: 100px; height: 100px; background-color: red; } 特点： 后代选择器首选要满足包含（嵌套）关系。 父集元素在前边，子集元素在后边。 无限制隔代。（下面都会生效） 只要能代表标签，标签、类选择器、ID选择器自由组合。 子代选择器 示例： div&gt;span { width: 100px; height: 100px; background-color: red; } 特点： 选中直接下一代元素，下下一代就选不中了。 并集选择器 示例： div, span, .box { color: red; } 特点： ","link":"https://tingke.github.io/post/3TADld0ke/"},{"title":"前端基础之认识前端","content":"1、什么是前端 前端对于网站来说，通常是指网页，网站的前台部分包括网站的表现层和结构层。因此前端技术一般分为前端设计和前端开发。 前端设计一般可以理解为网站的视觉设计，比如 UI 设计； 前端开发则是网站的前台代码实现，包括基本的HTML和CSS以及JavaScript/ajax，现在最新的高级版本HTML5、CSS3，以及SVG等。 前端开发的核心部分主要是：HTML，CSS，JavaScript 三个部分。 HTML 是这三者中最基础的部分，相当于是网页的骨架，也就是网页的结构； CSS 部分是网页的表现形式，也可以说是网页的美化，比如一个图片的大小、位置，文字的大小颜色等； JavaScript 是一种动态的脚本语言，负责与用户进行交互，增加用户体验的作用。 2、网页组成 一个网页的组成部分主要包括下面几个部分：文字、图片、输入框、视频、音频、超链接 等。 3、Web 标准 说道 Web 标准，不能不说 W3C 组织（World Wide Web Consortium），全程为「万维网联盟」。万维网联盟创建于1994年，是Web技术领域最具权威和影响力的国际中立性技术标准机构。 W3C 最重要的工作是发展 Web 规范（称为推荐，Recommendations），这些规范描述了 Web 的通信协议（比如 HTML 和 XHTML）和其他的构建模块。简单的说就是就是确定 Web 页面的语法格式和规范的。 与之类似的一个组织是「European Computer Manufacturers Association」（ECMA组织），这个组织制定了标准的脚本语言规范 ECMAScript ，而 JavaScript 就参照的这个规范。 那么 Web 标准规范了下面三个部分： HTML 标准（结构标准 ），相当人的骨架结构。 CSS 样式（表现）标准 ， 相当于给人化妆变的更漂亮。 JavaScript 行为标准 ， 相当与人在唱歌，页面更灵动。 4、浏览器内核 浏览器内核是一个浏览器的核心部分，也就是「渲染引擎」。它的主要作用是决定一个浏览器如何显示网页的内容及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同。 这里涉及到一个「兼容性问题」，浏览器兼容性问题又被称为网页兼容性或网站兼容性问题，指网页在各种浏览器上的显示效果可能不一致而产生浏览器和网页间的兼容问题。所以我们在编写代码的时候，做好浏览器兼容，才能够让网站在不同的浏览器下都正常显示。而对于浏览器软件的开发和设计，浏览器对标准的更好兼容能够给用户更好的使用体验。 5、认识 HTML HTML 全程为：超文本标记语言（Hyper Text Markup Language）。这里超文本就是超链接的意思，就是可以实现页面的跳转。 6、HTML 结构标准 HTML 基本结构如下： &lt; !doctype html&gt; 声明文档类型 &lt;html&gt; 根标签 &lt;head&gt; 头标签 &lt;title&gt;标题标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 主体标签 &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt; 是告诉浏览器，以下文件用 HTML 哪个版本解析，这里是 HTML5 版本。 &lt;html&gt;&lt;/html&gt; 标签是一个网页的根标签，所有的标签都要写在这一对根标签里面。 &lt;head&gt;&lt;/head&gt; 是头标签，主要是定义文档（网页）的头部，包括完档的属性和信息，文档的标题，还可以引入 JavaScript 脚本，CSS 格式等。 &lt;body&gt;&lt;/body&gt; 是一个文档的主题，里面包含文档的所有内容，比如文本，超链接，图片，表格等内容。 7、html 标签分类 单标签 &lt;! Doctype html&gt; 双标签 &lt;html&gt; &lt;/html&gt; ，&lt;head&gt;&lt;/head&gt;， &lt;title&gt;&lt;/title&gt; 8、html 标签关系分类 包含（嵌套关系）&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt; 父子关系 并列关系 &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 兄弟姐妹 9、开发工具 前期学习一种语言的时候，开发工具很重要。Web开发工具有很多。最简单的一个开发工具就是 Windows 系统自带的记事本了，但是又难用又难看，没有语法高亮、代码补全等功能。 那么我推荐大家使用的是「vscode」 代码编辑器，它虽小巧精致，但有着炫酷的界面，并且有大量的插件可以使用，大大提高了代码的编写效率。 提到 Web 开发工具不得不提到 JebBrain 全家桶的「 Webstorm 」软件。目前已经被广大 Web 开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。它令人称到的是它智能打代码补全、代码一键格式化、HTML 提示、联想查询、代码重构等强大功能。 建议初学者初期使用Sublime等文本编辑器，太过于智能的编辑器确实会带给我们极大地便利，但是在带给我们便利的同时，也会削弱我们对基础知识的掌握，只有自己一个单词一个单词敲出来的代码，才会让我们记得更加牢固。 ","link":"https://tingke.github.io/post/e_CCmMcGI/"},{"title":"Flutter 安装与入门","content":"Flutter 入门 网站： 官方：https://flutter.io/docs/development/tools/ide/vs-code 中文网：https://flutterchina.club/setup-macos/ 安装与配置： 下载Flutter cd ~ git clone -b master https://github.com/flutter/flutter.git vscode 安装 Flutter 插件 本地配置路径 vim ~/.zshrc 输入以下代码 #for flutter by 2018-11-13 export PATH=/Users/kun/flutter/bin:$PATH export PUB_HOSTED_URL=https://dart-pub.mirrors.sjtug.sjtu.edu.cn export FLUTTER_STORAGE_BASE_URL=https://mirrors.sjtug.sjtu.edu.cn vscode 导入本地 Flutter SDK cd 到 Flutter 根目录 运行 flutter doctor 安装相关包 简单命令 flutter -h // 帮助 flutter create 【文件名称】 // 创建工程 flutter run // 运行,默认运行 lib/main.dart,如果 main 函数不 在main.dart 中需指定文件 常用快捷键 r 键：点击后热加载，也就算是重新加载吧。 R 键：点击后热重载，也就算是重新加载吧。 p 键：显示网格，这个可以很好的掌握布局情况，工作中很有用。 o 键：切换android和ios的预览模式。 q 键：退出调试预览模式。 ","link":"https://tingke.github.io/post/flutter-an-zhuang-yu-ru-men/"},{"title":"CSS 四大布局","content":"CSS 四大布局 本文简单介绍 CSS 中的一些常见布局 1. 流式布局 流式布局遵守标准文档流规则，通过CSS改变标签的display属性 block/inline-block。 HTML 中有 block 和 inline-block 两种标签，它们在流式布局中具有不同的表现： inline-block 标签可以嵌套在 block 标签中，反之则不可； 可以通过 display 修改标签属于 block 或者 inline-block 类型； block 类型的标签布局是每一个标签独占一行，而 inline-block 标签会一个挨着一个进行布局； 2. 定位 通过 position 的方式可以打破流式布局，它支持的值有：static，relative，absolute，fix 和 sticky。 static：默认值，它遵循流水布局； relative：相对布局，需要结合 top、bottom、left 和 right 配合使用，仅设置 position:relative 属性不管作用。它不会打破默认的布局的方式，只会在默认的布局方式发生偏移 absolute：绝对布局，这种布局方式会 使元素脱离原有的流式布局 fix：它的作用就是把某个元素固定到某个位置，比如把下面的标题「Web布局方式」始终固定到顶部，无论如何滑动都不会改变其位置。 sticky：它的作用是在某个位置固定某个元素的位置，比如滑动到某个位置后，让其固定。 .div2 { /* 绝对定位:脱离标准文档流，相对父级元素位置定位 */ background-color: blue; position: absolute; right: 50px; bottom: 50px; } .div3 { /* 固定定位:脱离标准文档流，固定于网页窗口位置定位 */ background-color: green; position: fixed; left: 250px; top: 250px; } .div4 { background-color: green; /* 继承父级元素的定位属性 */ position: inherit; left: 250px; top: 250px; } 3. Flexbox Flexbox 布局是通过 CSS 中的属性 display：flex 来控制的，布局时需要指定一个容器 flex container，然后把要布局的元素放到容器中，这些元素被称为 flex item Flexbox 会把整个布局按两根轴（主轴（main axis），与主轴交叉的轴（cross axis））来布局。最外层为容器，容器内部为 item。整个布局思路就是按照不同的轴对 item 进行布局。 Flex相关属性： flex-direction: 布局方向，决定子元素要按照什么方向进行布局，也就是「主轴」的方向。 flex-wrap: 定义子元素「超出」容器后该如何布局; no-wrap：可超出 | wrap：自动换行 | wrap-reverse：反向主轴排序自动换行 flex-flow: 为 flex-direction | flex-wrap 的复合 justify-content: 「主轴」的对齐方式；flex-start：左对齐 | flex-end：右对齐 | center：居中 | space-between：两端对齐，项目之间间隔相等 | space-around：项目两侧间隔相等，中间间隔是两边的2倍 align-items: 定义交叉轴的对齐方式; center：居中对齐 | flex-start：左对齐 | flex-end：右对齐 | stretch：拉伸 | baseline：基线 align-content: 如果存在多行，将对多行进行对齐，如果只有一行将不起作用，它会影响 align-items 的对齐方式； Flex-item相关属性： order : 控制显示顺序，默认值为 0，可以设置负数和整数。值越小越往前排，值越大越往后排 flex-grow : 表示当容器存在「剩余空间」时，该如何分配剩余空间，默认值为 0，也就是说不会分配剩余空间 flex-shrink : 当容器空间不足时该如何缩小子元素，默认值为 1。如果设置为 0，即使容器空间不足，也不会缩小； flex-basic ：它表示占用的最小空间，计算剩余空间会利用这个值来计算。 flex ：为 flex-grow, flex-shrink, flex-basic 的混合值，默认为0 1 auto； align-self : 对齐方式，它默认继承自父元素的 align-items 值，可通过这个属性来修改这个值 .container { display: flex; /* # row 主轴就是 X 轴的方向（默认） #row-reverse 主轴的相反方向 #column 主轴方向为 Y 轴 #column-reverse 主轴的相反方向 */ flex-direction: column; text-align: center; } .container1 { display: flex; /* flex-wrap: 定义子元素「超出」容器后该如何布局; */ flex-wrap: wrap; /* justify-content: 「主轴」的对齐方式； */ justify-content: center; /* align-items: 定义交叉轴的对齐方式; */ } .container1 div { /* width: 50px; height: 50px; */ padding: 60px; background-color: blue; box-sizing: border-box; display: inline; margin: 10px; } .container1 div:nth-child(3) { background-color: red; order: 1; flex-grow: 1; align-self: center; } .footer { background-color: yellow; } 4. Grid 它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。 Flex 布局是轴线布局，只能指定&quot;项目&quot;针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成&quot;行&quot;和&quot;列&quot;，产生单元格，然后指定&quot;项目所在&quot;的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。 ","link":"https://tingke.github.io/post/css-si-da-bu-ju/"},{"title":"Code Review 机制和实施方案","content":"开展 Review 的目的 Code Review应该是软件工程最最有价值的一个活动。首先，我们先来看看Code Reivew的用处： Code reviews 中，可以通过大家的建议增进代码的质量。 Code reviews 是一个传递知识的手段，可以让其它并不熟悉代码的人知道作者的意图和想法，从而可以在以后轻松维护代码。 Code reviews 也鼓励程序员们相互学习对方的长处和优点。 Code reviews 也可以被用来确认自己的设计和实现是一个清楚和简单的。 Code reviews 不应该承担发现代码错误的职责。Code Review主要是审核代码的质量，如可读性，可维护性，以及程序的逻辑和对需求和设计的实现。代码中的bug和错误应该由单元测试，功能测试，性能测试，回归测试来保证的 Code reviews 不应该成为保证代码风格和编码标准的手段。编码风格和代码规范都属于死的东西，每个程序员在把自己的代码提交团队Review的时候，代码就应该是符合规范的，这是默认值，属于每个人自己的事情，不应该交由团队来完成，否则只会浪费大家本来就不够的时间。 Code Review的原则 经常进行Code Review 当你面对那近万行的代码，以前N多掺和在一起的功能，你会发现，整个Code Review变得非常地艰难，用不了一会儿，你就会发现大家都在拼命地打着哈欠，但还是要坚持，有时候，这样的Review会持续3个小时以上，相当的夸张。 Code Review不要太正式，而且要短 只有不正式的Code Review才会让你和评审者放轻松，人只有放松了，才会表现得很真实，很真诚。记住Review只不过是一种形式，而只有在相互信任中通过相互的讨论得到了有意义和有建设性的建议和意见，那才是最实在的。 尽可能的让不同的人Review你的代码 不同的人可以全面的从各个方面评论你的代码，有的从实现的角度，有的从需求的角度，有的从用户使用的角度，有的从算法的角度，有的从性能效率的角度，有的从易读的角度，有的从扩展性的角度…… 保持积极的正面态度 无论是代码作者，还是评审者，都需要一种积极向上的正面的态度，作者需要能够虚心接受别人的建议，因为别人的建议是为了让你做得更好；评审者也需要以一种积极的正面的态度向作者提意见，因为那是和你在一个战壕里的战友。记住，你不是一段代码，你是一个人！ 学会享受Code Review 如果你到了一个人人都喜欢Code Reivew的团阿，那么，你会进入到一个生机勃勃的地方，在那里，每个人都能写出质量非常好的代码，在那里，你不需要经理的管理，团队会自适应一切变化，他们相互学习，相互帮助，不仅仅是写出好的代码，而且团队和其中的每个人都会自动进化 如何开展Code Review 目前业界运作CodeReview的方式有多种方式：强制&amp;非强制、线上交流&amp;线下会议、小片段&amp;大模块、事前&amp;事后、高频率&amp;低频率，等等……据了解，目前每种形态都有各自的市场，被不同的团队运用着。 接下来分析下各种形态的优缺点，供大家参考： 强制&amp;非强制： 按照经验，CodeReview启动前期建议采用强制要求，否则很难有效开展起来。坚持一段时间待习惯养成后再考虑自由度。 小片段&amp;大模块：如果想要让问题暴露更充分或降低review的难度，建议采用细粒度方式进行，即小片段提交小片段review。如果更关注全局设计和逻辑思路的学习和找茬，那么可以用模块方式统一review。但很多时候这两种方式是可以结合运作的。 线上交流&amp;线下会议： 如果想提高效率，建议采用线上方式进行交流，这里要推荐公司的Code平台，上面支持CodeReview的功能都已经比较齐全。如果更喜欢全员一起找茬的那种快感，那么可以采用线下会议方式开展，但采用开会的方式，一般成本较高，可看团队接受度。 事前&amp;事后：这里指的是发布前还是发布后。版本发布后统一进行CodeReview的方式更多是一种代码交流活动， 起不到代码质量把关的作用。反之，如果在版本发布前就对代码进行CodeReview，就可以对质量问题起到很好的把关作用。这里是时间和质量之间的权衡。 高频率&amp;低频率：建议的是把代码交流放在每一天，所以频率越高越好。具体根据团队实际情况进行安排即可。 此外，也有团队采用模块owner把关质量的CodeReview方式，这种更多是从质量风险规避角度上考虑，在代码提交前owner检查是否有质量问题，确认没有问题后方能发布，有这方面需要的团队也可以考虑这种方式。 代码审查清单 设计常规项 设计是否合理符合通常设计模式， 逻辑是否考虑闭环全面考虑 扩展性是否考虑 是否存在安全漏洞 编码常规项 代码是否内存泄漏，是否UI成红色，是否性能低下，是否会形成crash 各种异常逻辑是否处理 代码能够工作么？它有没有实现预期的功能，逻辑是否正确等。 所有的代码是否简单易懂？ 代码符合你所遵循的编程规范么？这通常包括大括号的位置，变量名和函数名，行的长度，缩进，格式和注释。 是否存在多余的或是重复的代码？ 代码是否尽可能的模块化了？ 是否有可以被替换的全局变量？ 是否有被注释掉的代码？ 循环是否设置了长度和正确的终止条件？ 是否有可以被库函数替代的代码？ 是否有可以删除的日志或调试代码？ 安全 所有的数据输入是否都进行了检查（检测正确的类型，长度，格式和范围）并且进行了编码？ 在哪里使用了第三方工具，返回的错误是否被捕获？ 输出的值是否进行了检查并且编码？ 无效的参数值是否能够处理？ 文档 是否有注释，并且描述了代码的意图？ 所有的函数都有注释吗？ 对非常规行为和边界情况处理是否有描述？ 第三方库的使用和函数是否有文档？ 数据结构和计量单位是否进行了解释？ 是否有未完成的代码？如果是的话，是不是应该移除，或者用合适的标记进行标记比如‘TODO’？ 测试 代码是否可以测试？比如，不要添加太多的或是隐藏的依赖关系，不能够初始化对象，测试框架可以使用方法等。 是否存在测试，它们是否可以被理解？比如，至少达到你满意的代码覆盖(code coverage)。 单元测试是否真正的测试了代码是否可以完成预期的功能？ 是否检查了数组的“越界“错误？ 是否有可以被已经存在的API所替代的测试代码？ 参考阅读： 为什么要坚持code review Code Review 不知道什么时候你会进行到这一步？ 基于GitLab的Code Review教程 这四类Code Review方法你都知道吗？ 代码review总结 我们的代码规范 百度的代码规范 ","link":"https://tingke.github.io/post/code-review-ji-zhi-he-shi-shi-fang-an/"},{"title":"FileMerge的基本使用","content":"作为一个开放人员，比较代码和合并代码是常有的事，以前都是用Beyond Compare这软件来比较的，后面发现Xcode自带的FileMerge也挺好用的，还省的多下载一个软件。下面我将介绍下 XCode自带的FileMerge进行代码合并管理的使用。 首先。FileMerge是XCode 4.x 自带的一个管理代码合并的工具，在XCode中如果提交svn 或者 git的时候，在展示diff的时候，其实就用到了这个工具的部分功能。 首先FileMerge，不仅仅只是支持Compare，还能很好的支持merge。而merge是我们管理代码的时候经常性遇到的基础需求。废话少说。下面展示下FileMerge怎么使用 FileMerge 在 XCode的安装目录可以找到。如下图路径 打开应用后界面如下图： 界面很简单，接下来就是设置Left ，Right。Left Right就是你要比较的项目的根目录。请记住你Left 和 RIght。这个在接下来的操作中非常重要。好了，点击 Compare 进入 经过比较，灰色为完全相同的文件，黑色表示有不同之处的文件 使用Comparison打开文件 FileMerge是需要等你处理了所有不同处的Actions 以后，在关闭这个界面，回到上一层的时候。看到View 选项下面有 Merge 选项。Combine Filles 其实就是相当于应用你保存的Actions并合并代码。 ","link":"https://tingke.github.io/post/filemerge-de-ji-ben-shi-yong/"},{"title":"《图解HTTP》读书笔记","content":"TCP/IP 协议族分层 应用层 向用户提供应用服务，如：HTTP（HyperText Transfer Protocol，超文本传输协议）、FTP（File Transfer Protocol，文件传输协议）、DNS（Domain Name System，域名系统）等 传输层 为应用层提供处于网络连接中的客户端和服务端的数据传输，如 TCP（Transmission Control Protocol，传输控制协议）、UDP（User Data Protocol，用户数据报协议） 网络层 用来处理在网络上流动的数据包，为数据包的传输选择一条传输线路，如：IP（Internet Protocol，网际协议） 数据链路层 处理连接网络的硬件部分，如：光纤、网卡、驱动等 传输图解 与 HTTP 紧密相连的TCP/IP 协议族 负责传输的 IP 协议 “IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。 IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。” 确保可靠性的 TCP 协议 “为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）” TCP 为什么是三次握手，不是两次或四次呢？ 三次握手： “喂，你听得到吗？” “我听得到呀，你听得到我吗？” “我能听到你，今天balabala……” 两次握手： “喂，你听得到吗？” “我听得到呀” “喂喂，你听得到吗？” “草，我听得到呀！！！！” “你TM能不能听到我讲话啊！！喂！” “……” 四次握手： “喂，你听得到吗？” “我听得到呀，你听得到我吗？” “我能听到你，你能听到我吗？” “……不想跟傻逼说话” --来自知乎的段子 可以看出四次握手显得过于庸余，而两次握手并不能确定双方的链接稳定了。 负责域名解析的 DNS 协议 计算机善于处理长串数字，但不容易理解名称；用户善于记忆名称，而不习惯记忆长串数字，于是 DNS 协议应运而生。 “DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务” HTTP 与 DNS/TCP/IP 关系图 URI 和 URL URI:（Uniform Resource Identifier，统一资源标识符） URL：(Uniform Resource Locator，统一资源定位符） URI基本格式： 协议方案：获取访问资源时要指定协议类型，如ftp、https等 登录信息：指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）可选 片段标识：使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置） HTTP 协议 一个 HTTP 协议必定有两端，请求访问资源的一端为客户端，提供资源响应的一端为服务器端，并且 HTTP 协议能明确区分哪是客户端哪是服务器端。 下面是从客户端发送给某服务器的请求报文 GET 表示访问服务器的类型，俗称“方法” //feed/v1/feed/get_attention_list?...uid= 指明了访问的资源对象，也叫做“URI” HTTP/1.1 及 HTTP 的版本号，用来提示客户端使用的http协议功能 请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。 响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成 “HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理” “HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了” HTTP 方法 类型 作用 GET 获取资源 POST 传输实体的主体 PUT 传输文件 HEAD 获取报文首部 DELETE 删除文件 OPTIONS 查询支持的方法 TRACE 追踪路径 CONNECT 要求用隧道协议连接代理 方法名区分大小写，请注意要用大写字母 持久连接 “持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了” “持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求” Cookie 的状态管理 “Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态” HTTP 报文内的 HTTP 信息 用于 HTTP 协议交互的信息被称为 HTTP 报文。 HTTP 报文结构 HTTP 首部字段 通用首部字段 字段名 说明 Cache-Control 控制缓存的行为 Connection 逐跳首部、连接的管理 Date 创建报文的日期 Pragma 报文指令 Trailer 报文末端的首部一揽 Transfer-Encoding 报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的信息 Warning 错误通知 请求首部字段 字段名 说明 响应首部字段 字段名 说明 实体首部字段 字段名 说明 HTTP 返回的状态码 状态码 含义 2XX 表明请求被正常处理 200 “表示从客户端发来的请求在服务器端被正常处理” 204 “代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分” 206 “表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容” 3XX 表明浏览器需要执行某些特殊的处理以正确处理请求 301 “永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI” 302 “临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问” 303 “由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。” 304 “表示客户端发送附带条件的请求 2 时，服务器端允许请求访问资源，但未满足条件的情况” 307 “临时重定向。该状态码与 302 Found 有着相同的含义。” 4XX “表明客户端是发生错误的原因所在。” 400 “该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求” 401 “该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息” 403 “该状态码表明对请求资源的访问被服务器拒绝了” 5XX “表明服务器本身发生错误” 500 “该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障” 503 “表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求” HTTP 的缺点 HTTP 主要有这些不足，例举如下。 通信使用明文（不加密），内容可能会被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改 ","link":"https://tingke.github.io/post/lesslesstu-jie-httpgreatergreater-du-shu-bi-ji/"},{"title":"被苹果弃用的PCH","content":"PCH是什么？ PCH是苹果为了提高编译速度引入的一个预编译文件，它所引用的内容能够被项目中的其他文件共享和访问，预编译后的头文件会被缓存起来，再次编译的时候就不需要重新编译 PCH 文件中导入的内容，从而提高编译速度。在Xcode6以前，新增的工程中会自动生成 “工程名-Prefix.pch”文件。 相信很多iOS开发者都使用 PCH 文件做过以下一些事： 存放一些宏定义 引入全局使用的头文件 开关日志打印 这样的在编码的时候，不用在不同文件中不停的做引用，编写代码的速度简直快的飞起😂😂。 这么爽的编码体验，苹果为什么放弃主动引入PCH？ 正是iOS开发者的滥用 PCH 文件，造成项目编译缓慢，影响用户体验，与苹果当初引入 PCH 的目的背道而驰了，因此苹果不得不放弃 PCH 的使用。 我想，罪魁祸首就是开发者大量引入共用性不高的宏定义和头文件，每次修改引入内容造成 PCH的重编译；编译的时候整个工程范围地查找和替换这些宏定义字段，重复导入这些头文件，不慢就奇怪了。 正确的使用方式 不要把所有的宏定义都放到平常文件中，尤其是共用性较小的宏定义; 将公用性高的头文件放到 PCH 中，比如Fundation框架等 将零散的宏定义专门创建一个头文件来放置，再导入到 PCH 中，方便查看和修改 其实，过分依赖 PCH 文件也有一些问题：它降低了代码的可移植性。把类中使用的框架等放在 PCH 中，要么你要重新去导入，要么把 PCH 一同拖走，还要删掉没用的代码，代价也是蛮大的。 ","link":"https://tingke.github.io/post/bei-ping-guo-qi-yong-de-pch/"},{"title":"Vue.js入门","content":"Vue.js是什么 Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 官方网站：https://cn.vuejs.org/ 安装 引入Vue.js环境 你可以创建一个 .html 文件，然后通过如下方式引入 Vue： &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; NPM 在用 Vue 构建大型应用时推荐使用 NPM 安装[1]。NPM 能很好地和诸如 webpack 或 Browserify 模块打包器配合使用。同时 Vue 也提供配套工具来开发单文件组件。 $ npm install vue 命令行工具（CLI） Vue 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具为现代化的前端开发工作流提供了开箱即用的构建配置。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目： # 全局安装 vue-clir $ npm install --global vue-cli # 创建一个基于 webpack 模板的新项目 $ vue init webpack my-project # 安装依赖，走你 $ cd my-project $ npm run dev [warning] CLI 工具假定用户对 Node.js 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下通读指南，在熟悉 Vue 本身之后再使用 CLI。 Vue实例 每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： var vm = new Vue({ // 选项 }) 常用选项 el:提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。 data: Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问。 &lt;body&gt; &lt;h1&gt;vue-component组件&lt;/h1&gt; &lt;hr&gt; &lt;div id=&quot;app&quot;&gt; {{ msg }}&lt;br&gt; &lt;a href=&quot;#&quot;&gt;我是tingke&lt;/a&gt;' &lt;/div&gt; &lt;div id=&quot;app1&quot;&gt; &lt;a href=&quot;#&quot;&gt;我是{{msg}}&lt;/a&gt;' &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: '#app', data: { msg: '123' }, }); var app1 = new Vue({ el: '#app1', data:{ msg: '321' } }); &lt;/script&gt; &lt;/body&gt; methods: 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。 computed:计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。 var app =new Vue({ el: '#app', data: { cash: 100, newsList:[ {title:'香港或就“装甲车被扣”事件追责 起诉涉事运输公司',date:'2017/3/10'}, {title:'日本第二大准航母服役 外媒：针对中国潜艇',date:'2017/3/12'}, {title:'中国北方将有明显雨雪降温天气 南方阴雨持续',date:'2017/3/13'}, {title:'起底“最短命副市长”：不到40天落马，全家被查',date:'2017/3/23'}, ] }, computed: { money: function () { return '￥' + this.cash + '元'; }, list: function () { var arr = this.newsList.slice(); return arr.reverse(); } } }) watch:一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 var suggestion=['T恤短袖','夹克长裙','棉衣羽绒服']; var app =new Vue({ el: '#app', data:{ temperature:14, suggestion:'夹克长裙' }, methods:{ add:function(){ this.temperature+=5; }, reduce:function(){ this.temperature-=5; } }, watch:{ // 监听温度，【注意】不应该使用箭头函数来定义 watcher 函数 temperature:function(newVal,oldVal){ if(newVal&gt;=26) { this.suggestion=suggestion[0]; }else if(newVal&lt;26 &amp;&amp; newVal &gt;=0) { this.suggestion=suggestion[1]; }else { this.suggestion=suggestion[2]; } } } }); 实例生命周期钩子 beforeCreate:在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 creaated:在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount:在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted:el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate: 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。 updated:由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子 beforeDestroy:实例销毁之前调用。在这一步，实例仍然完全可用 destroyed:Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 指令 基本介绍 v-text：主要用于文本的渲染。和 {{ Mustache }} 功能一样。但是 {{ Mustache }} 在第一次页面Vue木有初始化完成会显示 {{ Mustache }} 字符。故文本渲染多用v-text。 &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt; &lt;!-- 和下面的一样 --&gt; &lt;span&gt;{{msg}}&lt;/span&gt; [info] 如果遇到更新部分的 textContent ，需要使用 {{ Mustache }} 插值。 v-html：更新元素的 innerHTML 。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译 。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。 v-model:主要是在表单里面使用。比如文本框、下拉框、单选、复选、textarea。v-model是一个双向的功能。文本框输入以后，模型也会发生改变。反之模型改变了文本框也会改变。 v-show：控制显示隐藏。dom是存在的。仅仅加 display block, display none。 [warning] 注意，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else。 v-if：控制显示隐藏。如果dom不显示，整个dom没有不存在。 v-bind：绑定属性。给一个dom元素添加属性。【比如：在做图片的渲染过程中，如果图片的src地址是动态的，那么就需要v-bind去绑定src属性，去给这个src赋值。】。凡是样式变化的可能用v-bind动态去操作class 【不要在原生的class里面去使用 {{ Mustache }} 改变class】 v-for：循环。主要用于表格，&lt;li&gt; 标签去循环一个数组。【凡是看到列表就要v-for】 v-on：事件绑定。【v-on：同等于@】，用于需要人机操作交互的地方 v-cloak：这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。 在使用 HTML 绑定 Vue实例时，在页面加载时会闪烁。为了效果更明显，我们可以延后加载 Vue 实例。 setTimeout(() =&gt; { new Vue({ el: '#app', data: { msg: 'hello' } }) },2000) 而 v-cloak 可以解决这一问题，在 css 中加上 [v-cloak] { display: none; } 此时，页面会在实例编译完成后显示。 v-pre：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。 &lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt; v-once：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。 &lt;div v-once&gt; &lt;h1&gt;comment&lt;/h1&gt; &lt;p&gt;{{msg}}&lt;/p&gt; &lt;/div&gt; 常见问题 v-if与v-show区别？ v-if 是'真正的'条件渲染,因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建. v-if 也是惰性的,如果在初始渲染时条件为假，那么什么都不做，直到条件第一次为真的时候才会开始渲染条件块。 相比之下，v-show 就简单得多 不管初始条件是什么,元素总会被渲染,并且只是简单的基于 css 进行切换 display 属性. 一般来说,v-if 有更高的切换开销,而 v-show 有更高的出事渲染开销.因此,如果需要非常频繁的切换,那么使用 v-show 好一点;如果在 运行时条件不太可能改变,则使用 v-if 好点. 注意，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else。 为什么我用的 v-cloak 无效？ 在实际项目中，我们常通过 @import 来加载 css 文件 @import &quot;style.css&quot; @import &quot;index.css&quot; 而 @import 是在页面 DOM 完全载入后才会进行加载，如果我们将 [v-cloak] 写在 @import 加载的 css 文件中，就会导致页面仍旧闪烁。 为了避免这种情况，我们可以将 [v-cloak] 写在 link 引入的 css 中，或者写一个内联 css 样式，这样就得到了解决。 其他问题 什么是字符串模板？什么是HTML模板？ 你写在html中的 就是非字符串模板。你写在js中的 template:&quot;&quot;,这个就是字符串 模板 ","link":"https://tingke.github.io/post/vuejs-ru-men/"},{"title":"iOS打包静态库SOP","content":"今天，领导要求将App中网络请求的核心代码打包成静态库。故上网研究了一下静态库打包的相关知识，边看边试的打包成功了。现在在这里总结下： 库的基本知识 1、 什么是库？ 所谓库就是程序代码的集合，是共享程序代码的一种方式。 2、 库的分类 根据程序代码的开源情况，库可以分为两类 开源库 源代码是公开的，你可以看到具体实现。比如GitHub上比较出名的第三方框架AFNetworking、SDWebImage。 闭源库 不公开源代码，只公开调用的接口，看不到具体的实现，是一个编译后的二进制文件。这种常见于一些公司的SDK包，比如高德地图SDK、环信即时通讯SDK等等。而闭源库又分为两类：静态库和动态库。本篇重点要讲的便是其中的静态库。 3、静态库和动态库的存在形式和使用区别 存在形式： 静态库 以&quot;.a&quot;或者“.framework”为文件后缀名 动态库 以&quot;.dylib&quot;或者“.framework”为文件后缀名 使用区别： 静态库链接时会被完整的复制到可执行文件中，被多次使用就有多份拷贝。 动态库链接时不复制，程序运行时由系统动态加载到内存，供程序调用。而且系统只加载一次，多个程序共用，节省内存。 .a文件静态库打包 步骤一、新建一个新工程或在老项目中新建一个新Target，选择Cocoa Touch Static Library 步骤二、修改静态库的配置 buildSeting -&gt; Build Active Architecture Only设为NO，使编译后的库支持所有架构。 buildSeting -&gt; iOS Deployment Target设置静态库支持的iOS版本 步骤三、新建或拖入需打包的内容 步骤四、设置公开.h文件 步骤五、选中本Target,Command+B编译（一般编译两次，模拟器的Debug状态和真机的Release状态）。 Products中的libKPPW变黑表示编译成功，右键Show in Finder打开静态库路径 步骤六、打开终端，输入以下命令合并模拟器和真机的静态库 lipo -create 真机库的路径 模拟器库的路径 -output 合并后新库的路径 .framework文件静态库打包 步骤跟制作 .a 静态库基本一致，但要注意一下几点： 选择 framework 编译时默认制作成动态库，要在下面选择 合并静态库的时候，要选择 .framework 文件里的 libstaticclib 文件 ","link":"https://tingke.github.io/post/ios-da-bao-jing-tai-ku-sop/"},{"title":"编写高质量iOS与OS X代码的52个有效方法","content":"第一章 熟悉Objective-C 第1条：了解Objective-C语言的起源 Objective-C语言由Smalltalk演化而来，后者是消息型语言的鼻祖。消息与函数调用之间的区别看上去就像这样： // Function calling (oc) Object *obj = [Object new]; [obj performWith:parameter1 and:parameter2]; // Function calling (c++) Objcet *obj = new Object; obj-&gt;perform(parameter1,parameter2); 关键区别在于：**使用消息结构的语言，其运行时所执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定。**如果范例代码中调用的函数是多态的，那么在运行时就有按照“虚方法表”来查出到底应该执行哪个函数实现。而采用消息结构的语言，不论是否多态，总是在运行时才会去查找所要执行的方法。实际上，编译器甚至不关心接收消息的对象是何种类型。接收消息的对象问题也要在运行时处理，其过程叫做“动态绑定”（dynamic binding），第11条会详述其细节。 Objective-C是C的超集，只有同时掌握了C和OC的核心概念，方能写出高效的OC代码。 第2条：在类的头文件中尽量少引入其他头文件 尽量晚的引入类的头文件，只有在用到类的实现时，才引入其头文件。这样做能减少一定的编译时间，降低耦合。 无法使用@class向前声明，比如某个类要遵循协议，这个协议在另一个类中声明的，可以将此协议单独放在一个头文件中或放在分类当中，以降低引用成本。 第3条：多用字面量语法，少用与之等价的方法 使用字面量创建字符串、数值、数组、字典更简洁易读，也避免了nil问题。 字面量无法创建对应的可变类型 自定义子类无法使用字面量创建对象 第4条：多用类型常量，少用#define预处理命令 类型常量带有类型信息，#define没有 在.m文件中定义的常量为局部常量，其名称可不加前缀 在.h文件使用extern声明，并在.m文件中定义其值的常量为全局常量，其名称以相关类名做前缀，加以区分 第5条：多用枚举表示状态、选项和状态码 在处理枚举类型的switch语句中不要实现default分支。这样在加入新枚举时，编译器会提示switch语句未处理全部枚举 第二章 对象、消息、运行期 第6条：理解“属性”这一概念 属性是由实例变量+对应的存取方法构成 使用@dynamic声明的属性，编译器不会自动生成对应实例变量和存取方法 属性设置各种”特质“也会影响编译器生成对应的存取方法，如“atomic”、”readonly”、“strong”、”weak”等 第7条：在对象内部尽量访问实例变量 直接读取实例变量获取数据，这样不经过OC的“方法派发”，编译器生成的代码会直接访问实例变量的那块内存中的值，而不是走方法发消息，这样更快。 使用属性写入数据，能确保相关的”内存管理语义”得到贯彻。 在初始化及dealloc方法中，应该直接使用实例变量读写数据，避免子类复写了setter方法造成的异常 使用了懒加载的属性，应该一直使用属性来读写数据，避免实例变量未初始化 第8条：理解“对象等同性”这一概念 ==来判等对象时，是比较的俩个指针本身，而不是所指的对象 若要判断对象的等同性，请提供isEqual:和hash方法 编写hash方法时，请选择计算速度快、碰撞几率小的算法 等同对象必须有相同的哈希值，相同哈希值的对象不一定等同。 第9条：以”类簇模式“隐藏细节 类簇是一种很有用的设计模式，它通过提取所有对象的公共部分组成”抽象基类“，将不同对象的实现隐藏在公共接口背后。 第10条：在既有类中使用关联对象存放自定义数据 objc_setAssociatedObject和objc_getAssociatedObject,如何使用在这里就不多说了。值得强调的一点是，用关联对象可能会引入难于查找的bug，所以可能要看情况谨慎选择 第11条：理解objc_msgSend的作用 在Objective-C中，调用一个方法: id returnValue = [object messageName:parameter]; 它会转化为 id returnValue = objc_msgSend(object,@selector(messageName),parameter); 所以，消息传递的核心函数是： void objc_msgSend(id self, SEL cmd, ...) 它能就收2个及以上的参数，第一个代表接受者，第二个代表选择子，后续参数为传递的参数。 它的调用顺序是： 搜索接受者所属类中的“方法列表”，若能找到与选择子名称相符的方法，就跳转至此方法 若未找到，就沿着继承体系向上查找，若找到相符的跳转至该方法 若未找到，执行“消息转发” 第12条：理解消息转发机制 第13条：用“方法调配技术”调试“黑盒方法” 方法调配又称为**“method swizzling”**，使用另一份实现来替换原有的方法实现。 在运行期中，可以向类中新增或替换选择子所对应的方法实现 void method_exchangeImplementations(Method m1, Method m2) 第14条：理解“类对象”的用意 每一个Class都有一个isa指针指向一个唯一的Meta Class 每一个Meta Class的isa指针都指向最上层的Meta Class，这个Meta Class是NSObject的Meta Class。(包括NSObject的Meta Class的isa指针也是指向的NSObject的Meta Class，也就是自己，这里形成了个闭环) 每一个Meta Class的super class指针指向它原本Class的 Super Class的Meta Class (这里最上层的NSObject的Meta Class的super class指针还是指向自己) 最上层的NSObject Class的super class指向 nil 第三章 接口和API设计 第15条：用前缀避免命名空间冲突 Objective-C没有类似其他语言那样的命名空间机制(namespace)，比如说PHP中的 &lt;?php namespace Root\\Sub\\subnamespace; 这就会导致当你不小心实现了两个相同名字的类，或者把两个相对独立的库导入项目时而他们又恰好有重名的类的时候该类所对应的符号和Meta Class符号定义了两次。所以很容易产生这种命名冲突，让程序的链接过程中出现出现重复的符号造成报错。 为了避免这种情况，我们要尽量在类名，以及分类和分类方法上增加前缀，还有一些宏定义等等根据自己项目来定吧 第16条：提供“全能初始化方法” 在类中提供一个全能初始化方法，并与文档中指明。其他初始化方法均应调用此方法。 若全能初始化方法此超类不同，则需覆写超类中的方法。 如果超类的初始化方法不适用于子类，那么应覆写这个超类方法，并在其中抛出异常。 第17条：实现description方法 实现description或debugDescription方法，方便调试时打印更多有用的信息。 第18条：尽量使用不可变对象 封装对象提供最小的访问权限： 只用于对象内部修改的属性使用readonly修饰 可变集合不要作为属性公开，而是应该提供相关的方法修改集合。 //Language.h @property (nonatomic, strong) NSSet *set; 应该改为 //Language.h @property (nonatomic, strong, readonly) NSSet *languages; - (void)addLanguage:(NSString *)language; - (void)removeLanguage:(NSString *)language; //**.m @implementation Language { NSMutableSet *mutableLanguages; } - (NSSet *)languages { return [_mutableLanguages copy]; } - (void)addLanguage:(NSString *)language { [_mutableLanguages addObject:language]; } - (void)removeLanguage:(NSString *)language { [_mutableLanguages removeObject:language]; } 第19条：使用清晰而协调的命名方式 方法的命名规范 如果方法的返回值是新创建的，那么方法名的首个词应该是返回值的类型，除非前面还有修饰语，例如localizedString。属性的存取方法不遵循这种命名方式，因为一般认为这些方法不会创建新对象，即便有时返回内部对象的一份拷贝，我们也认为那相当于原有的对象。这些存取方法应该按照其所对应的属性来命名。 eg: + (instancetype)string; 应该把表示参数类型的名词放在参数前面。 eg:- (int)intValue 如果方法要在当前对象上执行操作，那么就应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。 eg:- (BOOL)hasPrefix:(NSString *)str 不要使用str这种简称，应该用string这样的全称。 eg:- (BOOL)isEqualToString:(NSString *)aString Boolean属性应加is前缀。如果某方法返回非属性的Boolean值，那么应该根据其功能，选用has或is当前缀。 eg:- (BOOL)isEqualToString:(NSString *)aString 将get这个前缀留给那些借由“输出参数”来保存返回值的方法，比如说，把返回值填充到“C语言式数组”里的那种方法就可以使用这个词做前缀。 eg:- (void)getCharacters:(unichar *)buffer range:(NSRange)range 类与协议的命名 命名方式应该协调一致: 继承的子类命名中必须包含父类名 定义的委托协议，应该包含委托发起方的名称 总结： 方法名应该言简意赅，从左至右读起来像一个句子 方法名里不要使用缩略后的类型名称 方法名务必要确保风格一致 第20条：为私有方法名加前缀 加不加无所谓，只是为了区分公共方法和私有方法 苹果公司的私有方法以_开头 第21条：理解Objective-C错误模型 为什么不使用异常处理机制？ 答：事实上，OC是具备异常处理机制的，但是具体情况下不会启用该机制。原因是ARC下默认不是“异常安全”的。 理由是,如果抛出异常，那么本应该在作用域末尾释放的对象在现在不能自动释放了。 如果想生成“异常安全”的代码，需要设置编译标志“-fobjc-arc-exceptions”，并且需要引入额外的代码，在不抛出异常时，也照样执行这段代码。 即使不用ARC，也很难在抛出异常后不会导致内存泄露。 如何处理不那么严重的错误？ 答：另方法返回0/nil，或者使用NSError。 NSError的使用方法 第22条：理解NSCopying协议 什么是NSCopying协议？ 答：在OC开发中，使用对象时经常需要拷贝它，我们会通过copy/mutbleCopy来完成。如果想让自己的类支持拷贝，那必须要实现NSCopying协议，只需要实现一个方法： - (id)copyWithZone:(NSZone*)zone 当然如果要求返回对象是可变的类型就要用到NSMutableCopying协议，相应方法 ``` - (id)mutableCopyWithZone:(NSZone *)zone ``` 浅拷贝VS深拷贝 在拷贝对象时，需要注意拷贝执行的是浅拷贝还是深拷贝。深拷贝在拷贝对象时，会将对象的底层数据也进行了拷贝。浅拷贝是创建了一个新的对象指向要拷贝的内容。一般情况应该尽量执行浅拷贝。 第四章：协议与分类 第23条：通过委托和数据源协议进行对象间通信 委托模式：定义一套接口，某对象若要接受另一个对象的委托，则需遵从此接口，以便成为其“委托对象”。而这“另一个对象”则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。 委托属性以weak修饰， 相应事件或传值 数据与业务解耦 第24条：将类的实现代码分散到便于管理的数个分类中 相当于重构代码：将相关联的属性、方法封装到一个分类中 分散后的代码便于阅读 便于调试，分类名会被打印出来 第25条：总是为第三方类的分类名称加前缀 为分类名称及其方法加上你的专有前缀，以防覆盖了“主实现”或其他分类的方法，造成不可预知的错误 第26条：勿在分类中声明属性 属性是封装数据的方式。尽管技术上说，分类里也可以声明属性，但这种做法还是要尽量避免。因为它们无法把实现属性所需的实例变量合成出来。 第27条：使用“class-continuation分类”隐藏实现细节 “class-continuation分类”与其他分类不同，它必须定义在其所连续的那个类的实现文件里。 “class-continuation分类”中可以新增实例变量 “class-continuation分类”中可将只读属性扩展为读写 “class-continuation分类”中可声明协议，外部无从查之 第28条：通过协议提供匿名对象 应用场景： @property (nonatomic,weak) id&lt;UITableViewDelegate&gt; delegate; 只有遵守了UITableViewDelegate协议的类都可以成为deleagte属性，delegate也就是匿名的了。 有时对象类型 并不重要，重要的是 对象有没有实现某些方法，在此情况下级可以使用 匿名类型 来表达这一概念。 @interface EOCDatabaseManager : NSObject + (id)sharedInstance; - (id&lt;EOCDatabaseConnection&gt;)connectionWithIdentifier:(NSString *)identifier; @end 第五章：内存管理 第29条：理解引用计数 自动引用计数（ARC，Automatic Reference Counting）是指内存管理中对引用采取自动计数的技术； ObjC采用引用计数（reference counting）的技术来进行管理： 每个对象都有一个关联的整数，称为引用计数器； 当代码需要使用该对象时，则将对象的引用计数加1； 当代码结束使用该对象时，则将对象的引用计数减1； 当引用计数的值变为0时，表示对象没有被任何代码使用，此时对象将被释放。 与之对应的消息发送方法如下： 当对象被创建（通过alloc、new或copy等方法）时，其引用计数初始值为1； 給对象发送retain消息，其引用计数加1； 給对象发送release消息，其引用计数减1； 当对象引用计数归0时，ObjC給对象发送dealloc消息销毁对象。 autorelease就是自动释放，当給一个对象发送autorelease消息时，方法会在未来某个时间給这个对象发送release消息将其释放，在这个时间段内，对象还是可以使用的。 原理 : 对象接收到autorelease消息时，它会被添加到了当前的自动释放池中，当自动释放池被销毁时，会給池里所有的对象发送release消息。 设置ARC有效的编译方法如下： 指定编译器属性为：”-fobjc-arc”。 设置ARC无效的编译方法如下： 指定编译器属性为：”-fno-objc-arc”。 第30条：以ARC简化引用计数 使用ARC，可以省略对于引用计数的操作，所以在ARC下调用对象的retain，release，autorelease，dealloc方法时系统会报错。 这里要注意CoreFoundation 对象不归ARC管理，开发中如果有用到还是要谁创建谁释放，适时调用CFRetain/CFRelease。 第31条：在dealloc方法中只释放引用并解除监听 dealloc的调用时机：对象在经历其生命期后，最终会被系统回收，这时就会执行dealloc方法。 dealloc方法不能主动调用 dealloc方法中，尽量不要执行其他方法，因为系统已经当前这个待回收的对象彻底摧毁了，这时会出现异常错误或崩溃 第32条：编写“异常安全代码”时留意内存管理问题 OC中抛出异常的时候可能会引起内存泄漏，注意一下使用的时机，或者注意在@try捕获异常中清理干净。 第33条：以弱引用避免保留环 几个对象以某种方式相互引用，造成内存泄露，我们称之为循环引用。 为避免循环引用，常使用weak或unsafe_unretained修饰。 weak和unsafe_unretained的区别： 当引用的对象移除后，unsafe_unretained仍指向那个回收的实例，而weak指向nil。（所以weak比unsafe_unretained更安全） 第34条：以“自动释放池块”降低内存峰值 内存峰值：应用程序在某个时间段内的最大内存用量 自动释放池块会在线程执行下一次事件循环时清空 // 自动释放池块 @autoreleasepool{} // 在遍历大数组或大字典时，可以使用自动释放池块降低内存峰值 NSArray *people = /*一个很大的数组*/ NSMutableArray *employeesArray = [NSMutableArray new]; for (NSStirng *name in people) { @autoreleasepool { MLEmployee *employee = [MLEmployee alloc] initWithName:name]; [employeesArray addObject:employee]; } } 第35条：用“僵尸对象”调试内存管理问题 如何开启僵尸对象 什么是僵尸对象 开启之后，系统在回收对象时，不将其真正的回收，而是把它的isa指针指向特殊的僵尸类，变成僵尸对象。 僵尸对象有什么用 僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容以及其接收者的消息，然后终止应用程序。 第36条：不用使用retainCount 在苹果引入ARC之后retainCount已经正式废弃，任何时候都不要调用这个retainCount方法来查看引用计数了，因为这个值实际上已经没有准确性了。但是在MRC下还是可以正常使用 第六章：块与大中枢派发 第37条：理解“块”这一概念 块用^表示，后面接一对花括号，括号内是块的实现代码。 块可以捕获所有在它声明范围内的变量。(即保存一份指向这些变量的指针) 在块中被修改了值的变量要用__block修饰。块总能修改实例变量，所有实例变量不用加__block修饰 如果通过读取或写入操作了实例变量，也会自动捕获self。此时极易产生循环引用。 根据块在内存中的位置，块被分为3种类型： 全局块（NSGlobalBlock） 这种块运行时无需获取外界任何状态，块所使用的内存区域在编译器就可以完全确定，所以该块声明在全局内存中。如果全局块执行copy会是一个空操作，相当于什么都没做。 void(^block)() = ^{ NSLog(@&quot;I am a NSGlobalBlock&quot;); } 栈块（NSStackBlock） 栈块保存于栈区，超出变量作用域，栈上的block以及__block变量都会被销毁。 堆块（NSMallocBlock） 堆块内存保存于堆区，在变量作用域结束时不受影响。 总结： 1. 如果一个block中引用了全局变量，或者没有引用任何外部变量(属性、实例变量、局部变量)，那么该block为全局块。 2. 其它引用情况(局部变量，实例变量，属性)为栈块。 3. 如果block是栈块，将block对象赋值给其他对象时，此对象变成堆块（因为Clang编译器帮我们往block发送了copy消息） 第38条：为常用的块类型创建typedef 以typedef重新定义块类型，可令块的使用更加简单 // 从新定义 typedef void (^SuccessBlock)(id responseDic); - (void)getDataWithHost:(NSString *)host success:(void (^)(id responseDic))success; // 可修改为 - (void)getDataWithHost:(NSString *)host success:(SuccessBlock)success; 第39条：用handler块降低代码分散程度 在iOS开发中，我们经常需要异步执行一些任务，然后等待任务执行结束之后通知相关方法。相比于委托模式，使用handler块的代码更加简洁紧凑。 第40条：用块引用其属性对象时不要出现保留环 如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。 一定要找个适当的时机解除保留环，而不能把责任推给API的调用者。 第41条：多用派发队列，少用同步锁 在iOS开发中，如果有多个线程要执行同一份代码，我们可能需要加锁来实现某种同步机制。有人可能第一印象想到的就是@synchronized(self)，例如： - (NSString*)someString { @synchronized(self) { return _someString; } } - (void)setSomeString:(NSString*)someString { @synchronized(self) { _someString = someString; } } 这样写法效率很低，而且也不能保证线程中觉得的安全。如果有很多属性，那么每个属性的同步块都要等其他同步块执行完毕才能执行。 应该用GCD来替换： _syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //读取字符串 - (NSString*)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; } - (void)setSomeString:(NSString*)someString { dispatch_barrier_async(_syncQueue, ^{ _someString = someString; }); } 第42条：多用GCD，少用performSelector系列 为什么要谨慎使用performSelector 内存管理问题：在ARC下使用performSelector我们经常会看到编译器发出如下警告：warning: performSelector may cause a leak because its selector is unknown [-Warc-performSelector-leaks]。因为编译器无法确定将要执行的选择子具体是什么，也就无法插入适当的内存管理方法。 performSelector的返回值只能是void或对象类型。 performSelector无法处理带有多个参数的选择子，最多只能处理两个参数。 GCD中有很多方法可以替代performSelector使用 第43条：掌握GCD及操作队列的使用时机 GCD是纯C的API，任务以较轻量级的块来表示；而操作队列是OC的对象。 使用NSOperation及NSOperationQueue的优点： 支持取消某个操作：在运行任务前，可以在NSOperation对象上调用cancel方法，用以表明此任务不需要执行。不过已经启动的任务无法取消。GCD队列是无法取消的，GCD是“安排好之后就不管了（fire and forget）”。 支持指定操作间的依赖关系：一个操作可以依赖其他多个操作，例如从服务器下载并处理文件的动作可以用操作来表示，而在处理其他文件之前必须先下载“清单文件”。而后续的下载工作，都要依赖于先下载的清单文件这一操作。这时如果操作队列允许并发执行的话，后续的下载操作就可以在他依赖的下载清单文件操作执行完毕之后开始同时执行。 支持通过KVO监控NSOperation对象的属性：可以通过isCancelled属性来判断任务是否已取消，通过isFinished属性来判断任务是否已经完成等等。 支持指定操作的优先级：操作的优先级表示此操作与队列中其他操作之间的优先关系，优先级搞的操作先执行，优先级低的后执行。GCD的队列也有优先级，不过不是针对整个队列的。 重用NSOperation对象。在开发中你可以使用NSOperation的子类或者自己创建NSOperation对象来保存一些信息，可以在类中定义方法，使得代码能够多次使用。不必重复自己。 第44条：通过Dispath Group机制，根据系统资源状况来执行任务 dispatch group是GCD的一项特性，能够把任务分组。调用者可以等待这组任务执行完毕，也可以在提供回调函数之后继续往下执行，这组任务完成时，调用者会得到通知。 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIOITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create; for(id object in collection) { dispatch_group_async(group, queue, ^{ [object performTask]; }); } // 阻塞线程 dispatch_group_wait(group,DISPATCH_TIME_FOREVER); // 或者继续其他操作 dispatch_group_notify(group,dispatch_get_main_queue(),^{ // continue something }); 第45条：使用dispatch_one来执行只需运行一次的线程安全代码 常用于单例 + (id)sharedInstance { static EOCClass *sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] init]; }); return sharedInstance; } 第46条：不要使用dispatch_get_current_queue dispatch_get_current_queue 函数的行为常常与开发者所预期的不同，此函数已经废弃，只应做调试之用。 由于GCD是按层级来组织的，所以无法单用某个队列对象来描述&quot;当前队列&quot;这一概念。 dispatch_get_current_queue 函数用于解决由不可以重入的代码所引发的死锁，然后能用此函数解决的问题，通常也可以用&quot;队列特定数据&quot;来解决。 第七章：系统框架 第47条：熟悉系统框架 在Objective-C中除了Foundation 与CoreFoundation之外还有很多系统库，其中包括但不限于下面列出的这些： CFNetwork:此框架提供了C语言级别的网络通信能力，它将BSD socket抽象成了易于使用的网络接口。而Foundation则将该框架里的部分内容封装为Objective-C接口，以便进行网络通信。 CoreAudio:此框架所提供的C语言API可以用来操作设备上的音频硬件。 AVFoundation:此框架所提供的Objective-C对象可用来回访并录制音频及视频，比如能够在UI视图类里播放视频。 CoreData:此框架所提供的Objective-C接口可以将对象放入数据库，将数据持久化。 CoreText:此框架提供的C语言接口可以高效执行文字排版以及渲染操作。 SpriteKit :游戏框架 CoreLocation、MapKit :定位地图相关框架 Address Book框架:需要使用通讯录时才使用该框架 Music Libraries框架:音乐库相关框架 HealthKit框架：健康相关框架 HomeKit框架：为智能化硬件提供的框架 CloudKit : iCloud相关的框架 Passbook、PassKit框架：为了在应用中用户可以很容易的访问他们之前购买的活动门票、旅行车票、优惠券等等提供的框架 第48条：多用块枚举，少用for循环 - (void)test1 { NSArray *array = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;]; // OC1.0中的NSEnumerator遍历 NSEnumerator *xx = [array objectEnumerator]; NSString *str; while ((str = [xx nextObject]) != nil) { NSLog(@&quot;%@&quot;,[xx nextObject]); } } - (void)test2 { NSArray *array = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;]; // OC2.0 遵守NSFastEnumeration协议 for (NSString *str in array) { NSLog(@&quot;%@&quot;,str); } } - (void)test3 { NSArray *array = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;]; // 基于块的遍历 [array enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { NSLog(@&quot;%@&quot;,obj); }]; } 第49条：对自定义其内存管理语义的collection使用无缝桥接 什么是无缝桥接 OC集合对象与C语言的数据结构相互平滑转换被称为无缝桥接 如何使用无缝桥接 NSArray *anNSArray = @[@1, @2, @3, @4, @5]; CFArrayRef aCFArray = (__bridge CFArrayRef)anNSArray; NSLog(@&quot;Size of array = %li&quot;, CFArrayGetCount(aCFArray)); //Output: Size of array = 5 // __bridge:将oc对象转换为c的数据结构，arc依然具备这个对象的所有权。c的数据结构转换为oc对象，arc并没有对象的所有权 //__bridge_retain:将oc对象转换为c的数据结构，arc失去这个对象的所有权，故c的数据结构使用完毕后要添加CFRelease(aCFArray)将其释放 //__bridge_transfer:将c的数据结构转换为oc对象，arc获取对象所有权 ``` 第50条：构建缓存时使用NSCache而不是NSDictionary 使用NSCache时，当系统资源耗尽时，它会自动删减缓存 当键不支持拷贝时，使用NSCache只会保留键，而NSDictionary需要编写复杂代码实现。 NSCache是线程安全的，NSDictionary需要自己编写多线程下读取规则。 NSPurgeableData与NSCache搭配使用，可实现自动清楚数据的功能 第51条：精简initialize和load的实现代码 load方法在类刚刚加载进程序时调用，此时运行期系统还处于“脆弱状态”。可能有些类还没有加载进程序中。在执行load方法时程序会阻塞，所有不要load中写入复杂代码 initialize方法在类第一次调用时执行。此时所有类已经加载进程序中，运行期系统能确保initialize一定会在线程安全的环境中执行。 了解load和initialize方法的异同点 第五十二条：别忘了NSTimer会保留其目标对象 在iOS开发中经常会用到定时器:NSTimer，由于NSTimer会生成指向其使用者的引用，而其使用者如果也引用了NSTimer，那就形成了循环引用。 在dealloc方法中移除定时器，此时的dealloc并不会执行。 那么怎么解决呢？ // 使用block执行，避免引用self __weak typeof(self) weakself = self; [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) { __strong typeof(weakself) strongself = weakself; [strongself doSomething]; }]; ","link":"https://tingke.github.io/post/bian-xie-gao-zhi-liang-ios-yu-os-x-dai-ma-de-52-ge-you-xiao-fang-fa/"},{"title":"高效的使用Xcode 9","content":"随着iOS 11的发布，Xcode版本也升级到了9。那么这个版本的Xcode又有哪些变化呢？ 1. 跳转方法 以前按住Command键，单击任何方法名都可以跳转到方法声明处或者苹果文档中。但是现在却弹出个弹框，如图 此时却Command+Shift+左键才能跳转，才麻烦了。我们只需要在设置中这样就能设置回我们熟悉操作： 2. 折叠代码 Command+Option+左右箭头 = 折叠或打开代码块 3. 重构相关 对一个方法或者变量的重命名,在方法上CMD+单击,出现的菜单,选择rename 4. Folder和Group的同步性 之前,我们在XCode中,更改Folder的名字,在FInder中工程对应的文件夹的名字并不会同步的改变,这会造成我们重命名文件夹变得非常不方便,往往要先在XCode中移除,然后在Finder中重命名,再添加回Xcode 现在 在Xcode9中重名命Folder,Finder中的也同步的改变了 我们之前建议一个虚拟的group,并不会在对应的文件夹中建立真实的目录,当然,这可能是你需要的,也可能是你不需要的功能.在9中,默认行为改变了.变成了会建立对应的真实文件夹.如果还想像之前那样只是建立虚拟的group,需要选择New Group without Folder 你可能你会担心,区分不了这个group到底是虚拟的,还是实际的 放心,苹果给出了标识来区分的,虚拟的左下角有个小的三角形 5. runtime问题检测 在8中,已经包含了Address Scanitizer和Thread Scanitizer,在Xcode9中,又新增了 Undefiner Behavior Scanitizer,它可以实时的检测一系列的问题.不过我们更能明显感受到的是Main Thread Checker,它可以在运行时确保你没有把UI更新 代码写在了非主线程中 例如,代码中 可见还是很强大的,虽然我们没有Fabric的源码,但是其内部调用了[UIApplicationsharedApplication].statusBarOrientation],还是被检测到了 当然了,如果你想关掉它,可以在 scheme editor中操作 6. 模拟器可以多开了,并且,模拟器可以登录 模拟器的外观样式也回归了,直接是iPhone的外观了,以前可能是因为模拟器不能任意调整大小,所以才没外观的吧 当然了,你可以去掉外观皮肤. 在模拟器的Window show Device Bezels,去掉选项就和以前一样了 7. 无线开发 这个只支持ios11的机器,很简单,只要在Device那打开支持就行. 8. 调整字体 cmd +/- 可以用来调整编辑器的字体大小了 9. 关于警告 我们定义一个不带参数的block,通常是如下的方式 typedef void (^UpdateSwichBtnBlock)(); 在xcode9中会提示一个警告 This block declaration is not a prototype Insert ‘void' 解决方式可以是如下的几种 typedef void (^UpdateSwichBtnBlock)(void); 但是这样,很多第三方要改,涉及的面太大了,目前可能不太适合,虽然这个是趋势. pragma #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wstrict-prototypes&quot; typedefvoid (^UpdateSwichBtnBlock)(); #pragma clang diagnostic pop 彻底的暂时解决所有这种警告的方式 在工程的设置中 设置为NO,则这些警告就消失了 不过这不是一种好习惯,只是暂时性的不让提示这种类型的警告而已 10. crash可以直接在本机上看到了 11. Xcode 在全屏模式下使用 Simulator 如果你用的是 13 寸的电脑，那么 Xcode 的全屏模式你应该早已习惯，其实即使是配有显示器，我还是习惯在 Xcode 的全屏模式下开发😎。很可惜的是不能在 Xcode 的全屏模式下使用 Simulator, 自 Xcode 9b3 以后，这个问题便不存在了： 这个功能并不是对所有人默认开放的，如果不幸你的 Xcode 没有默认开启这个功能也不要灰心，我们可以通过打开 Apple Internal menu 来启用这个功能，通过 Apple Internal menu 你能挖掘出 Simulator 的更多新特性。那么问题来了，怎么开启 Apple Internal menu 呢？首先，在更目录里创建 AppleInternal 文件夹，然后重启 Simulator: cd ~/ sudo mkdir /AppleInternal 多重启 Simulator 后就可以看到 internal 选项 ☝ 但是， 我在 Mac 使用过程中遇到 Operation Not Permitted 问题，之前都是略过，今天好好摸索了一把，搞明白了道理，记录下来。 好几次整理移动硬盘数据的时候，都遇到了 Operation Not Permitted 问题，文件移动不了，也删除不掉，第一次遇到没理会，第二次是打开虚拟机，在 Windows 中操作这些问题文件，今天又遇到了，决定消灭它。 OS X EI Capitan 的 SIP Apple 在 OS X 10.11 以后的版本中默认启动了一项系统保护程序，叫做 System Integrity Protection，也被唤作 rootless（寓意让 root 弱一点），该程序意在保护电脑不被恶意程序攻击，但是对于我们这群程序员，很多保护是多余的，甚至给我们带来了很多麻烦。 SIP 会锁定几个系统文件目录： /System /sbin /usr （/usr/local 除外） 在 SIP 的保护下，部分软件、功能、脚本都会失效，我们可以通过如下步骤关闭 SIP： 重启电脑，按下 Command + R 直到听到开机声音，此时电脑会进入恢复模式（Recovery Mode） 当 OSX 工具出现在屏幕中时，下拉工具（Utilities）菜单，选择终端（Terminal） 键入 csrutil disable，回车 电脑重启后，SIP 就关闭了 恢复 SIP 的方式同上，只不过终端中键入 csrutil enable。通过 csrutil status 可以检测系统当前 SIP 的启动状态： $ csrutil status System Integrity Protection status: enabled. 补充： 使用命令行，在录制当前模拟器的屏幕 xcrun simctl io booted recordVideo --type=mp4 &lt;PATH TO VIDEO FILE&gt; 上传文件到模拟器中 打开url(所有苹果的URL计划列表请查阅文档。) xcrun simctl openurl booted &lt;URL&gt; 参考阅读： iOS Simulator on steroids: Tips &amp; Tricks ","link":"https://tingke.github.io/post/gao-xiao-de-shi-yong-xcode-9/"},{"title":"iOS11下的适配工作","content":" 今年的苹果，发布iOS 11的同时，也大胆的发布了异型屏iPhone X。独特的“刘海”造型又在手机样式方面独领风骚。但是这也为iOS开发工作增加了难度。 iPhone X的屏幕尺寸相关变化 高度增加了145pt，变成812pt. 屏幕圆角显示，注意至少留10pt边距。 状态栏高度由20pt变成44pt，留意这个距离就能避开“刘海”的尴尬，相应的导航栏以上变化64-&gt;88。 底部工具栏需要为home indicator留出34pt边距。 物理分辨率为1125px * 2436px，使用@3倍图 本次系统升级带来了以下内容： 集成了搜索的大标题栏 提倡在安全区域内布局 导航栏的titleView支持自动布局 废除了xxx，新增了xxx App中必须添加 1024 x 1024 的应用图标的图片 App启动图片适配 相信有一部分道友的APP在iPhone X上运行时并没有像想象中那样占满整个屏幕, 而是保持着原有的高度 在屏幕中心位置, 针对这个问题 目前经过实验得出可以通过以下方式使APP按照全屏模式运行: 通过LaunchScreen.storyboard方式启动 如果使用的是Assets中的LaunchImage, 在增加了iPhone X尺寸的图片配置后. LaunchScreen.storyboard方式不用多说, 这里说一下如何在LaunchImage中增加iPhone X尺寸的图片配置. 准备一张尺寸:1125 * 2436的启动图片, 移动到LaunchImage的Finder目录中, 并在LaunchImage中的Contents.json文件中增加 (注意Json格式): { &quot;extent&quot; : &quot;full-screen&quot;, &quot;idiom&quot; : &quot;iphone&quot;, &quot;subtype&quot; : &quot;2436h&quot;, &quot;filename&quot; : &quot;图片名.png&quot;, &quot;minimum-system-version&quot; : &quot;11.0&quot;, &quot;orientation&quot; : &quot;portrait&quot;, &quot;scale&quot; : &quot;3x&quot; } iOS 11为UIView增加了两个新的属性safeAreaInsets和safeAreaLayoutGuide, 通过这两个属性我们可以获得安全区域的范围, 通过上图可以很清楚的看到安全区域的范围, 我们要做的是让那些不能被遮挡的内容和控件在安全区域范围内显示, 注意!这句话非常重要. safeAreaInsets 适用于手动计算. safeAreaLayoutGuide 适用于自动布局. UINavigation 大标题 在UI navigation bar中新增了一个BOOL属性prefersLargeTitles,将该属性设置为ture，navigation bar就会在整个APP中显示大标题，如果想要在控制不同页面大标题的显示，可以通过设置当前页面的navigationItem的largeTitleDisplayMode属性； if (@available(iOS 11.0, *)) { self.navigationController.navigationBar.prefersLargeTitles = YES; } titleView引入自动布局 会导致titleView变形，只需要在自定义view中实现intrinsicContentSize方法 - (CGSize)intrinsicContentSize { return UILayoutFittingExpandedSize; } 加入searchController属性 把你的UISearchController赋值给navigationItem，就可以实现将UISearchController集成到Navigation。 if (@available(iOS 11.0, *)) { self.navigationItem.searchController = self.searchController; self.navigationItem.hidesSearchBarWhenScrolling = YES; }else{ self.searchController.searchBar.bounds = CGRectMake(0, 0, self.view.frame.size.width, 44); self.tableView.tableHeaderView = self.searchController.searchBar; [self.tableView setContentOffset:CGPointMake(0, 44)]; } UITableView 在iOS 11中默认启用Self-Sizing 这个应该是UITableView最大的改变。我们知道在iOS8引入Self-Sizing 之后，我们可以通过实现estimatedRowHeight相关的属性来展示动态的内容，实现了estimatedRowHeight属性后，得到的初始contenSize是个估算值，是通过estimatedRowHeight x cell的个数得到的，并不是最终的contenSize，tableView就不会一次性计算所有的cell的高度了，只会计算当前屏幕能够显示的cell个数再加上几个，滑动时，tableView不停地得到新的cell，更新自己的contenSize，在滑到最后的时候，会得到正确的contenSize。 Self-Sizing在iOS11下是默认开启的，Headers, footers, and cells都默认开启Self-Sizing，所有estimated 高度默认值从iOS11之前的 0 改变为UITableViewAutomaticDimension。 iOS11下不想使用Self-Sizing的话，可以通过以下方式关闭：（前言中提到的问题也是通过这种方式解决的） self.tableView.estimatedRowHeight = 0; self.tableView.estimatedSectionHeaderHeight = 0; self.tableView.estimatedSectionFooterHeight = 0; UIViewController automaticallyAdjustsScrollViewInsets &amp;&amp; contentInsetAdjustmentBehavior 在iOS 11之前，由于UIViewController的automaticallyAdjustsScrollViewInsets = true，在UI布局时，会出现界面中的第一个scrollView控件中的内容向下偏移64px。所以部分开发者会在开始UI布局时会将将automaticallyAdjustsScrollViewInsets = false。 而在iOS 11直接废除了这个属性，而在UIScrollView中添加了contentInsetAdjustmentBehavior属性来计算adjustedContentInset的范围。adjustContentInset表示contentView.frame.origin偏移了scrollview.frame.origin多少； /* 如果scrollview在一个automaticallyAdjustsScrollViewContentInset = YES的controller上， 并且这个Controller包含在一个navigation controller中， 这种情况下会设置在top &amp; bottom上 adjustedContentInset = safeAreaInset + contentInset不管是否滚动。 其他情况下与UIScrollViewContentInsetAdjustmentScrollableAxes相同 */ UIScrollViewContentInsetAdjustmentAutomatic, /* 在可滚动方向上adjustedContentInset = safeAreaInset + contentInset， 在不可滚动方向上adjustedContentInset = contentInset； 依赖于scrollEnabled和alwaysBounceHorizontal / vertical = YES，scrollEnabled默认为yes， 所以大多数情况下，计算方式还是adjustedContentInset = safeAreaInset + contentInset */ UIScrollViewContentInsetAdjustmentScrollableAxes, /* 不计算内边距,adjustedContentInset = contentInset */ UIScrollViewContentInsetAdjustmentNever, /* 根据safeAreaInsets 计算内边距,adjustedContentInset = safeAreaInset + contentInset */ UIScrollViewContentInsetAdjustmentAlways, iPhone X 在push时TabBar上移 总结 在iOS 11发布了不久后，APP适配iOS 11和iPhone X也是踩坑不少，把自己遇到过的坑记录下来，和大家一起分享。 参考文章： iOS11、iPhone X、Xcode9 适配指南 你可能需要为你的 APP 适配 iOS 11 关于iPhone X 的适配 ","link":"https://tingke.github.io/post/ios11-xia-de-gua-pei-gong-zuo/"},{"title":"iPhone X互交设计官方指南","content":"One More Thing! iPhone X来了，全面屏+独特的“刘海”造型。让我们来了解一下iPhone X吧。 iPhone X iPhone X包括一个大的、高分辨率的、圆形的、边对边的显示，它提供了前所未有的沉浸式、内容丰富的体验。 Screen Size 在竖屏方向，iPhoneX显示屏的宽度与iPhone 6、iPhone 7和iPhone 8 4.7显示器的宽度相匹配。但是在iPhone X比4.7寸屏幕高145pt，导致大约20%额外的垂直空间的内容。 在你的应用程序的所有切图必须提供高分辨率的图像。iPhone X有一个高分辨率屏幕，符号等的平面、矢量图形，最好是提供独立的PDF文件的分辨率。用于光栅化的切图，同时提供@3X和@2x版本的切图。参见 Image Size and Resolution 和Custom Icons。 Layout 当为iPhone X设计时，必须确保布局填满屏幕，而不是被设备的圆角、传感器外壳或访问主屏幕的指示器所掩盖。 大多数使用标准的、系统提供的UI元素（如导航栏、表格和集合）的应用程序会自动适应设备的新形式因素。背景材料扩展到显示的边缘，并且适当地插入和定位UI元素。 对于具有自定义布局的应用程序，支持 iPhone X 也应该比较容易，特别是如果您的应用程序使用 Auto Layout 并遵守安全区域和边距布局指南。 在 iPhone X 上预览您的应用程序。您可以使用 Simulator(附带 Xcode)来预览应用程序，并检查剪辑和其他布局问题。如宽彩色图像这样的属性，最好在设备上预览。 提供全屏体验。确保背景延伸到屏幕的边缘，并且垂直可滚动的布局(如表格和集合)一直延续到底部。 插入必要内容以防止裁剪。一般来说，内容应该是居中对称的，所以它在任何方向看起来都很棒，不会被角落或设备的传感器外壳裁剪，或被访问主屏幕的指示器遮挡。为获得最佳效果，请使用标准的系统提供的界面元素和 Auto Layout 构建您的界面。所有应用程序都应遵循 UIKit 定义的安全区域和布局边距，这些区域可以根据设备和上下文进行适当的填充。安全区域还可以防止内容覆盖状态栏、导航栏、工具栏和标签栏。 注意状态栏的高度。状态栏在 iPhone X 上比在其他 iPhone 上更高。如果您的应用程序的固定状态栏高度在状态栏的下方，则您必须更新您的应用程序，才能根据用户的设备动态定位内容。请注意，当背景任务(如录音和位置跟踪)处于活动状态时，iPhoneX 上的状态栏不会改变高度。 如果您的应用程序目前隐藏状态栏，请重新考虑 iPhone X 上的决定。iPhone 上的显示高度为 4.7 英寸，iPhone 的显示屏提供了更多的垂直空间内容，状态栏占据了您应用程序本可能赢得的屏幕区域，状态栏还显示了人们发现的有用的信息，只有在交换附加值时候才能被隐藏。 在重复使用现有图稿时，请注意长宽比差异。iPhone X 具有不同于 4.7 英寸 iPhone 的长宽比，因此，全屏 4.7 英寸 iPhone 图形在 iPhone X 上全屏显示时出现裁剪或 letterboxed。同样，全屏 iPhone X 图稿在显示时被裁剪或被添加黑边。 全屏显示在 4.7 英寸 iPhone 上，确保重要的视觉内容保持在两种显示尺寸上。 避免将交互式控件放置在屏幕最底部和角落里。人们使用显示屏底部的滑动手势访问主屏幕和应用程序切换器，这些手势可能会取消您在此区域中实现的自定义手势。屏幕的两个角落很难让人触及。 不要遮挡或突出显示关键的显示特性。请勿尝试隐藏设备的圆角、传感器外壳或通过在屏幕顶部和底部放置黑色条来指示主屏幕的指示器。不要使用像括号、边框、形状或教学文字等视觉装饰来让人注意这些区域。 允许自动隐藏虚拟Home键，以便轻松访问主屏幕。当启用自动隐藏时，如果用户没有触摸屏幕几秒钟，Home 键将自动隐藏。当用户再次触摸屏幕时，它会重新出现。这种行为应该只能用于被动观看体验，如播放视频或幻灯片。请参阅 适应性和布局。 参见 Adaptivity and Layout. StatusBar NavigationBar的标题 考虑在导航栏中显示当前视图的标题。在大多数情况下，标题帮助人们理解他们在看什么。然而，如果标题导航栏似乎是多余的，你可以把标题空。例如，Notes不会对当前的便笺进行标题，因为第一行内容提供了所需的所有上下文。 当需要额外强调上下文时，使用大标题。在一些应用程序中，大标题的粗体文本可以帮助人们浏览和搜索。在标签的布局，例如，大标题可以帮助澄清活动标签和通知用户当他们滚动到顶部。手机使用这种方法，而音乐使用大标题来区分内容区域，如专辑、艺术家、播放列表和广播。当用户开始滚动内容时，一个大标题转换为一个标准标题。大标题在所有应用程序中都没有意义，不应该与内容竞争。虽然时钟应用程序有一个选项卡式布局，但大标题是不必要的，因为每个选项卡都有一个独特的、可识别的布局。对于开发商的引导，参考preferslargetitles。 TabBar 本文翻译于Apple Developer ","link":"https://tingke.github.io/post/iphone-x-hu-jiao-she-ji-guan-fang-zhi-nan/"}]}